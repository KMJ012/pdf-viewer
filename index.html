<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23dc2626'%3E%3Cpath d='M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z'/%3E%3Ctext x='12' y='16' text-anchor='middle' fill='white' font-size='6' font-weight='bold' font-family='Arial'%3EPDF%3C/text%3E%3C/svg%3E" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            transition: background-color 0.4s ease, color 0.4s ease, border-color 0.4s ease;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: rgb(40, 40, 40);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background-color 0.4s ease;
        }

        /* 라이트 모드 */
        body.light-theme {
            background: #f8f9fa;
        }

        body.light-theme .toolbar {
            background: rgb(248, 249, 250);
            border-bottom: 1px solid #e1e5e9;
            color: #202124;
        }

        body.light-theme .file-title {
            color: #202124;
        }

        body.light-theme .toolbar-btn {
            color: #5f6368;
        }

        body.light-theme .toolbar-btn:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .toolbar-input {
            background: white;
            border: 1px solid #dadce0;
            color: #202124;
        }

        body.light-theme .toolbar-input:hover {
            background: #f8f9fa;
            border-color: #dadce0;
        }

        body.light-theme .toolbar-input:focus {
            background: white;
            border-color: #4285f4;
        }

        body.light-theme .zoom-select {
            background: white;
            border: 1px solid #dadce0;
            color: #202124;
        }

        body.light-theme .zoom-select:hover {
            background: #f8f9fa;
        }

        body.light-theme .zoom-select:focus {
            background: white;
            border-color: #4285f4;
        }

        body.light-theme .page-divider {
            color: #5f6368;
        }

        body.light-theme .sidebar {
            background: rgb(248, 249, 250);
            border-right: 1px solid #e1e5e9;
        }

        body.light-theme .icon-panel {
            background: rgb(241, 243, 244);
            border-right: 1px solid #e1e5e9;
        }

        body.light-theme .icon-btn {
            color: #5f6368;
        }

        body.light-theme .icon-btn:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .icon-btn.active {
            background: #4285f4;
            color: #fff;
        }

        body.light-theme .folder-section {
            background: rgb(248, 249, 250);
        }

        body.light-theme .folder-header {
            border-bottom: 1px solid #e1e5e9;
        }

        body.light-theme .folder-title {
            color: #202124;
        }

        body.light-theme .folder-tree {
            color: #5f6368;
        }

        body.light-theme .folder-item:hover {
            background: rgba(60, 64, 67, 0.08);
        }

        body.light-theme .folder-item.selected {
            background: #4285f4;
            color: white;
        }

        body.light-theme .folder-item.pdf-file {
            color: #202124;
        }

        body.light-theme .folder-item.pdf-file.selected {
            background: #4285f4;
            color: white;
        }

        body.light-theme .folder-empty {
            color: #5f6368;
            background: rgba(60, 64, 67, 0.04);
        }

        body.light-theme .folder-empty:hover {
            background: rgba(66, 133, 244, 0.08);
            color: #202124;
        }

        body.light-theme .thumbnail-item {
            background: white;
            border: 2px solid #e1e5e9;
        }

        body.light-theme .thumbnail-item:hover {
            border-color: #4285f4;
        }

        body.light-theme .loading-thumbnails {
            color: #5f6368;
        }

        body.light-theme .pdf-container {
            background: rgb(245, 245, 245) !important;
        }

        body.light-theme .loading {
            color: #5f6368;
        }

        body.light-theme .properties-dialog {
            background: white;
            color: #202124;
        }

        body.light-theme .properties-header {
            border-bottom: 1px solid #e1e5e9;
        }

        body.light-theme .properties-title {
            color: #202124;
        }

        body.light-theme .property-group:not(:last-child)::after {
            background: linear-gradient(90deg, transparent, #e1e5e9, transparent);
        }

        body.light-theme .property-label {
            color: #5f6368;
        }

        body.light-theme .property-value {
            color: #202124;
        }

        body.light-theme .properties-footer {
            border-top: 1px solid #e1e5e9;
        }

        body.light-theme .toast {
            background: white;
            color: #202124;
            border: 1px solid #dadce0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .upload-area {
            background: white;
            border: 2px dashed #dadce0;
        }

        body.light-theme .upload-area:hover {
            border-color: #4285f4;
            background: #f8f9fa;
        }

        body.light-theme .upload-icon {
            color: #9aa0a6;
        }

        body.light-theme .upload-text {
            color: #5f6368;
        }

        body.light-theme .folder-selected-message {
            background: white;
            border: 2px solid #e8f0fe;
        }

        body.light-theme .folder-selected-text {
            color: #5f6368;
        }

        body.light-theme .folder-selected-subtitle {
            color: #9aa0a6;
        }

        /* 라이트 테마에서 사용법 설명 텍스트 색상 */
        body.light-theme .upload-area div[style*="color: #888"] {
            color: #9aa0a6 !important;
        }

        body.light-theme .upload-area strong[style*="color: #ccc"] {
            color: #5f6368 !important;
        }

        /* 라이트 테마에서 강조 텍스트 색상 */
        body.light-theme .upload-area strong[style*="color: #4285f4"] {
            color: #1a73e8 !important;
        }

        body.light-theme .mobile-backdrop {
            background: rgba(60, 64, 67, 0.7);
        }

        /* 라이트 테마 - 텍스트 선택 색상 */
        body.light-theme .text-layer span::selection {
            background: rgba(26, 115, 232, 0.3);
            color: rgb(32, 33, 36);
        }

        body.light-theme .text-layer span::-moz-selection {
            background: rgba(26, 115, 232, 0.3);
            color: rgb(32, 33, 36);
        }

        /* 라이트 테마 - 썸네일 창 */
        body.light-theme .thumbnail-window-modal {
            background: rgba(60, 64, 67, 0.7);
        }

        body.light-theme .thumbnail-window {
            background: white;
            border: 1px solid #dadce0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        body.light-theme .thumbnail-window-header {
            background: #f8f9fa;
            border-bottom: 1px solid #e1e5e9;
            color: #202124;
        }

        body.light-theme .thumbnail-window-title {
            color: #202124;
        }

        body.light-theme .thumbnail-window-close {
            color: #5f6368;
        }
        
        body.light-theme .thumbnail-window-select-toggle {
            color: #5f6368;
        }

        body.light-theme .thumbnail-window-select-toggle:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .thumbnail-window-select-toggle.active {
            background: #4285f4;
            color: #fff;
        }

        body.light-theme .thumbnail-window-close:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item {
            background: white;
            border: 2px solid #e1e5e9;
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item:hover {
            border-color: #4285f4;
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item.active {
            border-color: #4285f4;
            box-shadow: 0 0 8px rgba(66, 133, 244, 0.5);
        }
        
        /* 선택된 축소판 스타일 */
        .thumbnail-window-grid .thumbnail-item.selected {
            border-color: #4285f4 !important;
            box-shadow: 0 0 16px rgba(66, 133, 244, 0.8) !important;
            transform: translateY(-2px) !important;
        }

        /* 라이트 테마에서도 동일한 스타일 적용 */
        body.light-theme .thumbnail-window-grid .thumbnail-item.selected {
            border-color: #4285f4 !important;
            box-shadow: 0 0 16px rgba(66, 133, 244, 0.8) !important;
            transform: translateY(-2px) !important;
        }
        
        /* 선택된 축소판에 체크 아이콘 추가 (우상단) */
        .thumbnail-window-grid .thumbnail-item.selected::after {
            content: '✓';
            position: absolute;
            top: 8px;
            right: 8px;
            background: #4285f4;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* 선택 모드일 때 축소판 스타일 */
        .thumbnail-window-grid .thumbnail-item.selection-mode {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .thumbnail-window-grid .thumbnail-item.selection-mode:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .thumbnail-window-grid .thumbnail-item.selection-mode:hover .selection-overlay {
            background-color: rgba(66, 133, 244, 0.1) !important;
            border-color: rgba(66, 133, 244, 0.5) !important;
        }

        /* 현재 페이지 스타일 (항상 우선) */
        .thumbnail-window-grid .thumbnail-item.active {
            border-color: #ff9800 !important; /* 주황색 테두리 */
            box-shadow: 0 0 16px rgba(255, 152, 0, 0.6) !important;
            transform: translateY(-2px) !important;
        }

        .thumbnail-window-grid .thumbnail-item.active .selection-overlay {
            border: 3px solid #ff9800 !important; /* 주황색 오버레이 테두리 */
        }

        /* 선택된 축소판 스타일 (현재 페이지가 아닐 때만) */
        .thumbnail-window-grid .thumbnail-item.selected:not(.active) {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
        }

        .thumbnail-window-grid .thumbnail-item.selected:not(.active):hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(66, 133, 244, 0.5);
        }

        /* 현재 페이지가 선택되었을 때 (주황색 + 파란색 조합) */
        .thumbnail-window-grid .thumbnail-item.active.selected {
            border-color: #ff9800 !important; /* 주황색 테두리 유지 */
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.8), 0 0 40px rgba(66, 133, 244, 0.3) !important; /* 주황색 + 파란색 그림자 */
            transform: translateY(-4px) !important;
        }

        .thumbnail-window-grid .thumbnail-item.active.selected .selection-overlay {
            background: linear-gradient(45deg, rgba(255, 152, 0, 0.2), rgba(66, 133, 244, 0.2)) !important; /* 그라데이션 배경 */
            border: 3px solid #ff9800 !important; /* 주황색 테두리 */
        }

        /* 라이트 테마 */
        body.light-theme .thumbnail-window-grid .thumbnail-item.selection-mode:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item.active {
            border-color: #ff9800 !important;
            box-shadow: 0 0 16px rgba(255, 152, 0, 0.5) !important;
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item.selected:not(.active) {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.3);
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item.selected:not(.active):hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(66, 133, 244, 0.4);
        }

        body.light-theme .thumbnail-window-grid .thumbnail-item.active.selected {
            border-color: #ff9800 !important;
            box-shadow: 0 0 20px rgba(255, 152, 0, 0.6), 0 0 40px rgba(66, 133, 244, 0.2) !important;
        }

        /* 스크롤바 스타일 - 다크 테마 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* 스크롤바 스타일 - 라이트 테마 */
        body.light-theme ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        body.light-theme ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        body.light-theme ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        /* PDF 컨테이너 배경 - 라이트 테마에서 더 밝게 */
        body.light-theme .pdf-container {
            background: #f8f9fa;
        }

        /* 로딩 텍스트 라이트 테마 */
        body.light-theme .loading {
            color: #5f6368;
        }

        /* 버튼 호버 효과 라이트 테마 */
        body.light-theme .toolbar-btn:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .fit-toggle-btn:hover {
            background: rgba(60, 64, 67, 0.08);
        }

        /* 라이트 테마 - 드롭다운 메뉴 */
        body.light-theme .dropdown-menu {
            background: white;
            border: 1px solid #dadce0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 999999; /* 라이트 테마에서도 동일한 높은 z-index */
        }
        body.light-theme .dropdown-menu {
            background: white;
            border: 1px solid #dadce0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 999999; /* 라이트 테마에서도 동일한 높은 z-index */
        }

        body.light-theme .dropdown-item {
            color: #202124;
        }

        body.light-theme .dropdown-item:hover {
            background: rgba(60, 64, 67, 0.08);
        }

        body.light-theme .dropdown-item.disabled {
            color: #9aa0a6;
        }

        body.light-theme .dropdown-item.disabled:hover {
            background: transparent;
        }

        body.light-theme .dropdown-separator {
            background: #e1e5e9;
        }

        /* 상단 툴바 z-index 강화 */
        .toolbar {
            background: rgb(60, 60, 60);
            border-bottom: 1px solid #333;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
            flex-shrink: 0;
            height: 63px;
            box-sizing: border-box;
            z-index: 10000 !important; /* 강력한 우선순위 */
            position: relative !important;
            min-width: 600px;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0; /* 섹션들이 줄어들지 않도록 */
        }

        .toolbar-section.left {
            flex: 1;
            justify-content: flex-start;
            min-width: 180px; /* 최소 너비 보장 */
            /* max-width 제거로 중앙 정렬 복원 */
        }

        .toolbar-section.center {
            flex: 0 0 auto;
            justify-content: center;
            min-width: 320px; /* 복사 버튼 추가로 최소 너비 증가 */
        }

        .toolbar-section.right {
            flex: 1;
            justify-content: flex-end;
            min-width: 100px; /* 최소 너비 보장 */
        }

        .toolbar-divider {
            color: #888;
            font-size: 14px;
            margin: 0 4px;
            flex-shrink: 0;
        }

        .file-title {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            /* 유동적으로 줄어들도록 수정 */
            flex: 1; /* 남은 공간을 차지하되 줄어들 수 있게 */
            min-width: 0; /* flexbox에서 텍스트가 줄어들 수 있게 하는 핵심 설정 */
            max-width: none; /* max-width 제한 제거 */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-left: 12px; /* 사이드바 버튼과의 간격 */
        }

        /* ===== PC에서 창이 좁아질 때를 위한 반응형 스타일 (모바일 디바이스 제외) ===== */

        /* 매우 좁은 창 (600px 이하) */
        @media (max-width: 600px) {
            body:not(.mobile-device) .toolbar {
                min-width: 400px;
                padding: 10px 8px;
            }
            
            body:not(.mobile-device) .file-title {
                max-width: 60px;
                font-size: 11px;
            }
            
            body:not(.mobile-device) .toolbar-section.center {
                min-width: 200px;
            }
            
            body:not(.mobile-device) .zoom-select {
                min-width: 60px;
                font-size: 11px;
            }
            
            body:not(.mobile-device) .toolbar-input {
                min-width: 35px;
                font-size: 11px;
            }
        }

        /* 좁은 창 (768px 이하) */
        @media (max-width: 768px) {
            body:not(.mobile-device) .toolbar {
                min-width: 500px;
                padding: 10px 12px;
            }
            
            body:not(.mobile-device) .file-title {
                max-width: 80px;
                font-size: 12px;
            }
            
            body:not(.mobile-device) .toolbar-section.center {
                min-width: 250px;
            }
        }

        /* 중간 창 (1024px 이하) */
        @media (max-width: 1024px) {
            body:not(.mobile-device) .file-title {
                max-width: 120px;
                font-size: 13px;
            }
        }

        /* ===== 실제 모바일 디바이스에서만 적용되는 스타일 ===== */
        body.mobile-device #sidebarToggle,
        body.mobile-device .toolbar-btn {
            z-index: 99999 !important;
            position: relative !important;
        }

        /* 툴바 스타일 */
        body.mobile-device .toolbar {
            padding: 8px 12px;
            gap: 10px;
            height: 63px;
            min-width: unset;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
            z-index: 99999 !important;
            position: relative;
        }

        /* 모바일에서 툴바 최상위 */
        body.mobile-device .toolbar {
            z-index: 999999 !important;
            position: relative !important;
        }

        body.mobile-device .toolbar * {
            z-index: 999999 !important;
            position: relative !important;
        }

        /* 모바일에서 사이드바는 툴바보다 낮게 */
        body.mobile-device .sidebar {
            z-index: 1500 !important;
        }

        body.mobile-device .mobile-backdrop {
            z-index: 1400 !important;
        }

        body.mobile-device .toolbar::-webkit-scrollbar {
            display: none;
        }

        body.mobile-device .toolbar-section {
            gap: 8px;
            flex-shrink: 0;
        }

        body.mobile-device .toolbar-section.left {
            flex: 1 1 auto;
            min-width: 120px;
            max-width: 200px;
            justify-content: flex-start;
        }

        body.mobile-device .toolbar-section.center {
            flex: 0 0 auto;
            min-width: 280px;
            justify-content: center;
        }

        body.mobile-device .toolbar-section.right {
            flex: 0 0 auto;
            min-width: 100px;
            justify-content: flex-end;
        }

        body.mobile-device .file-title {
            max-width: 100px;
            font-size: 11px;
            margin-left: 8px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        body.mobile-device .toolbar-btn,
        body.mobile-device .fit-toggle-btn {
            width: 32px;
            height: 32px;
            font-size: 14px;
            padding: 6px;
            z-index: 99999 !important;
            position: relative !important;
        }

        body.mobile-device #propertiesBtn {
            font-size: 18px;
        }

        body.mobile-device .toolbar-divider {
            font-size: 12px;
        }

        body.mobile-device .zoom-select {
            min-width: 65px;
            font-size: 12px;
            padding: 4px 8px;
        }

        body.mobile-device .toolbar-input {
            min-width: 40px;
            font-size: 12px;
            padding: 4px 8px;
        }

        /* 사이드바 스타일 */
        /* 모바일 사이드바 z-index 조정 */
        body.mobile-device .sidebar {
            position: fixed;
            top: 63px;
            left: 0;
            height: calc(100vh - 63px);
            width: 0;
            z-index: 1500; /* 드롭다운보다 낮게 유지 */
            transition: width 0.3s ease;
        }

        body.mobile-device .mobile-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1400; /* 드롭다운보다 낮게 유지 */
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 모바일에서 드롭다운이 열릴 때 사이드바 숨기기 방지 */
        body.mobile-device .sidebar.icon-panel-open {
            z-index: 1500; /* 드롭다운보다는 낮지만 유지 */
        }

        body.mobile-device .sidebar.icon-panel-open {
            width: 100vw;
        }

        body.mobile-device .sidebar.icon-panel-open.thumbnails-open {
            width: 100vw;
        }

        body.mobile-device .sidebar.icon-panel-open.folder-open {
            width: 100vw;
        }

        body.mobile-device .sidebar.icon-panel-open.thumbnails-open.folder-open {
            width: 100vw;
        }

        body.mobile-device .icon-panel {
            width: 48px;
            z-index: 200;
            pointer-events: auto;
        }

        body.mobile-device .icon-btn {
            width: 32px;
            height: 32px;
            font-size: 16px;
            pointer-events: auto;
        }

        body.mobile-device .thumbnails-section {
            width: calc(100vw - 48px);
            padding-top: 8px;
        }

        body.mobile-device .folder-section {
            width: calc(100vw - 48px);
            padding: 6px;
        }

        body.mobile-device .folder-title {
            font-size: 12px;
        }

        body.mobile-device .folder-select-btn {
            font-size: 10px;
            padding: 3px 6px;
        }

        /* 메인 콘텐츠 스타일 */
        body.mobile-device .main-content {
            margin-left: 0;
        }

        /* PDF 뷰어 스타일 */
        body.mobile-device .pdf-wrapper {
            align-items: center;
            justify-content: center;
        }

        body.mobile-device .pdf-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 문서 속성 모달 */
        body.mobile-device .properties-dialog {
            min-width: 300px;
            max-width: 90vw;
            padding: 20px;
        }

        body.mobile-device .property-group {
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        body.mobile-device .property-item {
            padding: 1px 0;
        }

        body.mobile-device .property-label {
            min-width: 100px;
            font-size: 12px;
        }

        body.mobile-device .property-value {
            font-size: 12px;
        }

        body.mobile-device .properties-close-btn {
            border-radius: 18px;
            padding: 6px 16px;
            font-size: 12px;
        }

        /* 썸네일 창 스타일 */
        body.mobile-device .thumbnail-window {
            width: 95vw;
            height: 80vh;
            max-width: none;
        }

        body.mobile-device .thumbnail-window-grid {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        /* 드롭다운 토스트 위치 조정 */
        body.mobile-device .toast-container.dropdown-open {
            right: 10px;
        }

        /* 도움말 모달 */
        body.mobile-device .help-dialog {
            min-width: 90vw;
            max-width: 95vw;
            max-height: 90vh;
            margin: 20px;
        }

        body.mobile-device .help-header {
            padding: 16px 20px;
        }

        body.mobile-device .help-content {
            padding: 16px 20px;
        }

        body.mobile-device .help-footer {
            padding: 12px 20px;
        }

        body.mobile-device .help-section h3 {
            font-size: 15px;
        }

        body.mobile-device .help-section li {
            font-size: 14px;
            margin-bottom: 6px;
        }

        body.mobile-device #sidebarToggle {
            width: 32px !important;
            height: 32px !important;
            font-size: 16px !important;
            z-index: 99999 !important;
            position: relative !important;
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }

        /* 모바일에서 툴바 버튼들이 숨겨지지 않도록 */
        body.mobile-device .toolbar-btn {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        .fit-toggle-btn {
            background: transparent;
            border: none;
            border-radius: 50%;
            padding: 8px;
            font-size: 16px;
            cursor: pointer;
            color: #fff;
            transition: all 0.2s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .fit-toggle-btn:hover {
            background: rgba(75, 75, 75, 0.5);
        }

        .fit-toggle-btn.active {
            background: #4285f4;
            color: #fff;
        }

        .fit-toggle-btn.active:hover {
            background: #3367d6;
        }

        .toolbar-btn.capture-mode {
            background: #ff6b6b;
            color: #fff;
        }

        .toolbar-btn.capture-mode:hover {
            background: #ff5252;
        }

        /* 메인 레이아웃 컨테이너 */
        .main-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            width: 100%;  /* 추가 */
        }

        /* 사이드바 */
        .sidebar {
            width: 0;
            background: rgb(50, 50, 50);
            border-right: 1px solid #333;
            transition: width 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            flex-direction: row;
            position: relative;
            z-index: 1500;
        }

        .sidebar.icon-panel-open {
            width: 48px;
        }

        .sidebar.icon-panel-open.thumbnails-open {
            width: 318px; /* 폴더와 동일한 크기로 고정 */
        }

        .sidebar.icon-panel-open.folder-open {
            width: 318px; /* 48px (아이콘) + 270px (폴더) */
        }

        .sidebar.icon-panel-open.thumbnails-open.folder-open {
            width: 318px; /* 고정 크기 유지 */
        }

        /* 모바일 사이드바 오버레이 */
        .mobile-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1400;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mobile-backdrop.show {
            display: block;
            opacity: 1;
        }

        /* 아이콘 패널 */
        .icon-panel {
            width: 48px;
            background: rgb(45, 45, 45);
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            flex-shrink: 0;
            opacity: 0;
            transform: translateX(-100%);
            transition: all 0.3s ease;
            z-index: 200;
            pointer-events: auto;
        }

        .sidebar.icon-panel-open .icon-panel {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
            pointer-events: auto;
        }

        .icon-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .icon-btn.active {
            background: #4285f4;
            color: #fff;
        }

        .icon-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        /* 썸네일 섹션 */
        .thumbnails-section {
            width: 270px;
            flex-shrink: 0;
            overflow-y: auto;
            padding: 16px;
            padding-top: 8px;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar.thumbnails-open .thumbnails-section {
            display: block;
            opacity: 1;
        }

        /* 폴더 탐색기 섹션 */
        .folder-section {
            width: 270px;
            flex-shrink: 0;
            overflow-y: auto;
            padding: 8px;
            background: rgb(50, 50, 50);
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .sidebar.folder-open .folder-section {
            display: block;
            opacity: 1;
        }

        .folder-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 4px;
            margin-bottom: 8px;
            border-bottom: 1px solid #444;
        }

        .folder-title {
            color: #ccc;
            font-size: 13px;
            font-weight: bold;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-select-btn {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .folder-select-btn:hover {
            background: #3367d6;
        }

        .folder-tree {
            color: #ccc;
            font-size: 13px;
            line-height: 1.4;
        }

        .folder-item {
            display: flex;
            align-items: center;
            padding: 2px 4px;
            cursor: pointer;
            border-radius: 3px;
            user-select: none;
            transition: background 0.1s ease;
        }

        .folder-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .folder-item.selected {
            background: #4285f4;
            color: white;
        }

        .folder-item.pdf-file {
            color: #fff;
        }

        .folder-item.pdf-file:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .folder-item.pdf-file.selected {
            background: #4285f4;
        }

        .folder-indent {
            margin-left: 16px;
        }

        .folder-icon {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .folder-icon.expandable {
            cursor: pointer;
            color: #888;
        }

        .folder-icon.expandable:hover {
            color: #ccc;
        }

        .folder-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-empty {
            color: #888;
            text-align: center;
            padding: 20px;
            font-size: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px dashed transparent;
            user-select: none;
        }

        .folder-empty:hover {
            background: rgba(66, 133, 244, 0.2);
            border-color: #4285f4;
            color: #ccc;
            transform: scale(1.02);
        }

        .folder-empty.dragover {
            background: rgba(66, 133, 244, 0.3);
            border-color: #4285f4;
            color: #fff;
            transform: scale(1.05);
        }

        .thumbnails-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .thumbnail-item {
            position: relative;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #444;
            overflow: hidden;
        }

        .thumbnail-item:hover {
            border-color: #4285f4;
        }

        .thumbnail-item.active {
            border-color: #4285f4;
            box-shadow: 0 0 8px rgba(66, 133, 244, 0.5);
        }

        .thumbnail-canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .thumbnail-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 12px;
            text-align: center;
            padding: 4px;
        }

        .loading-thumbnails {
            color: #ccc;
            text-align: center;
            padding: 20px;
            font-size: 14px;
        }

        /* 썸네일 창 모달 */
        .thumbnail-window-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999; /* 높은 z-index로 모든 것 위에 표시 */
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .thumbnail-window-modal.show {
            display: flex;
            opacity: 1;
        }

        .thumbnail-window {
            background: rgb(50, 50, 50);
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            width: 900px;
            height: 700px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            flex-direction: column;
        }

        .thumbnail-window-modal.show .thumbnail-window {
            transform: scale(1);
        }

        .thumbnail-window-header {
            background: rgb(60, 60, 60);
            padding: 16px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 양쪽 정렬 */
            border-bottom: 1px solid #666;
            flex-shrink: 0;
            position: relative; /* 중앙 정렬을 위해 추가 */
        }

        .thumbnail-window-title {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            position: absolute; /* 절대 위치로 중앙 정렬 */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .thumbnail-window-select-toggle {
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%; /* 동그라미 호버 */
            transition: all 0.2s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thumbnail-window-select-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .thumbnail-window-select-toggle.active {
            background: #4285f4;
            color: #fff;
        }

        .thumbnail-window-close {
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%; /* 동그라미 호버를 위해 추가 */
            transition: all 0.2s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thumbnail-window-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .thumbnail-window-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .thumbnail-window-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); /* 120px → 180px로 증가 */
            gap: 16px;
            align-items: start;
        }

        .thumbnail-window-grid .thumbnail-item {
            width: 100%;
            background: #444;
            border: 2px solid #666;
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .thumbnail-window-grid .thumbnail-item:hover {
            border-color: #4285f4;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .thumbnail-window-grid .thumbnail-item.active {
            border-color: #4285f4;
            box-shadow: 0 0 16px rgba(66, 133, 244, 0.6);
            transform: translateY(-2px);
        }

        .thumbnail-window-grid .thumbnail-canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .thumbnail-window-grid .thumbnail-label {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 11px;
            text-align: center;
            padding: 6px;
            font-weight: 500;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;  /* flexbox 버그 방지 */
            position: relative;  /* 추가 */
        }

        .toolbar-btn {
            background: transparent;
            border: none;
            border-radius: 50%;
            padding: 8px;
            font-size: 16px;
            cursor: pointer;
            color: #fff;
            transition: all 0.2s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        #propertiesBtn {
            font-size: 20px;
            font-weight: bold;
        }

        .toolbar-btn:hover {
            background: rgba(75, 75, 75, 0.5);
        }

        .toolbar-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toolbar-input {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 13px;
            min-width: 35px;
            text-align: center;
            color: #fff;
            background: rgb(30, 30, 30);
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        #pageInput {
            margin-right: -10px;
        }

        #zoomOut, #zoomIn {
            font-size: 25px;
            transition: color 0.2s ease;
        }

        #zoomOut.disabled, #zoomIn.disabled {
            color: rgb(129, 129, 129);
            cursor: not-allowed;
        }

        #zoomOut {
            margin-right: -10px;
        }

        #zoomIn {
            margin-left: -10px;
        }

        .toolbar-input:focus {
            outline: none;
            border-color: #4285f4;
            background: rgb(35, 35, 35);
        }

        .toolbar-input:hover {
            background: rgb(35, 35, 35);
        }

        /* 숫자 입력 필드의 증가/감소 버튼 숨기기 */
        .toolbar-input::-webkit-outer-spin-button,
        .toolbar-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            appearance: none;
            margin: 0;
        }

        .toolbar-input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .zoom-select {
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 5px 8px;
            font-size: 13px;
            background: rgb(30, 30, 30);
            color: #fff;
            cursor: pointer;
            min-width: 70px;
            text-align: center;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            flex-shrink: 0;
        }

        .zoom-select:hover {
            background: rgb(35, 35, 35);
        }

        .zoom-select:focus {
            outline: none;
            border-color: #4285f4;
            background: rgb(35, 35, 35);
        }

        .zoom-select option {
            background: rgb(30, 30, 30);
            color: #fff;
        }

        body.light-theme .zoom-select option {
            background: white;
            color: #202124;
        }

        body.light-theme .toolbar-input::-webkit-input-placeholder {
            color: #9aa0a6;
        }

        body.light-theme .toolbar-input:-moz-placeholder {
            color: #9aa0a6;
        }

        body.light-theme .toolbar-input::-moz-placeholder {
            color: #9aa0a6;
        }

        body.light-theme .toolbar-input:-ms-input-placeholder {
            color: #9aa0a6;
        }

        body.light-theme .loading {
            color: #5f6368;
        }

        /* 라이트 테마 - 캡쳐 오버레이 */
        body.light-theme .capture-overlay {
            background: rgba(255, 255, 255, 0.3);
        }

        body.light-theme .capture-guide {
            background: rgba(255, 255, 255, 0.9);
            color: #202124;
            border: 1px solid #dadce0;
        }

        body.light-theme .selection-area {
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
        }

        .page-divider {
            color: #ccc;
            font-size: 13px;
            margin: 0 6px;
            flex-shrink: 0;
        }

        /* 업로드 영역 - 기본 다크모드 */
        .upload-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgb(50, 50, 50);
            border: 2px dashed #555;
            margin: 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #ccc;
        }

        .upload-area:hover {
            border-color: #4285f4;
            background: rgb(45, 45, 45);
        }

        .upload-area.dragover {
            border-color: #4285f4;
            background: rgba(66, 133, 244, 0.1);
        }

        .upload-icon {
            font-size: 3em;
            color: #888;
            margin-bottom: 16px;
        }

        .upload-text {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 16px;
        }

        .upload-btn {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .upload-btn:hover {
            background: #3367d6;
        }

        .file-input {
            display: none;
        }

        /* 폴더 선택 완료 메시지 - 기본 다크모드 */
        .folder-selected-message {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgb(50, 50, 50);
            border: 2px solid #444;
            margin: 20px;
            border-radius: 8px;
            padding: 40px;
            color: #ccc;
        }

        .folder-selected-icon {
            font-size: 4em;
            color: #4285f4;
            margin-bottom: 20px;
        }

        .folder-selected-text {
            font-size: 18px;
            color: #ccc;
            margin-bottom: 16px;
            text-align: center;
        }

        .folder-selected-subtitle {
            font-size: 14px;
            color: #888;
            text-align: center;
            line-height: 1.6;
        }

        /* PDF 뷰어 */
        .pdf-viewer {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .pdf-container {
            flex: 1;
            background: rgb(40, 40, 40);
            overflow: auto;
            position: relative;
            width: 100%; /* 추가 */
            height: 100%; /* 추가 */
        }
        
        /* PDF 컨테이너 배경색 테마별 설정 */
        .pdf-container {
            background: rgb(40, 40, 40) !important;
            transition: background-color 0.4s ease !important;
        }

        .pdf-container.fit-page {
            overflow: hidden; /* 페이지 맞춤 모드에서는 스크롤 완전 금지 */
        }

        .pdf-container.fit-width {
            overflow-x: hidden !important; /* 가로 스크롤 완전 금지 */
            overflow-y: auto; /* 세로 스크롤만 허용 */
        }

        .pdf-wrapper {
            position: relative;
            min-width: 100%;
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: none !important;
            padding: 0; /* 패딩 초기화 추가 */
            box-sizing: border-box; /* 박스 사이징 추가 */
        }

        .pdf-content {
            position: relative;
            display: inline-block;
            margin: 0; /* margin 제거 */
            transition: none !important;
        }

        #pdfImage {
            display: block;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: none;
            max-height: none;
            position: relative;
            z-index: 1; /* 낮은 z-index 유지 */
            transition: transform 0.2s ease;
            will-change: transform;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        /* 숨겨진 캔버스 (렌더링용) */
        #pdfCanvas {
            display: none;
            position: absolute;
            top: -9999px;
            left: -9999px;
        }

        .text-layer {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            pointer-events: auto;
            z-index: 100; /* 낮은 z-index로 설정 */
            transition: transform 0.2s ease;
            will-change: transform;
        }

        .text-layer span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            font-family: sans-serif;
        }

        .text-layer span::selection {
            background: rgba(0, 100, 255, 0.3);
            color: rgb(166, 192, 215);
        }

        .text-layer span::-moz-selection {
            background: rgba(0, 100, 255, 0.3);
            color: rgb(166, 192, 215);
        }

        /* 캡쳐 오버레이 */
        .capture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1000; /* 드롭다운보다 낮게 설정 */
            cursor: crosshair;
            display: none;
            pointer-events: none;
        }

        .capture-overlay.active {
            display: block;
            pointer-events: auto;
        }

        .selection-area {
            position: absolute;
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
            pointer-events: none;
            display: none;
        }

        .capture-guide {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1001; /* 캡쳐 오버레이보다 위에 */
            display: none;
        }

        .capture-guide.show {
            display: block;
        }

        /* 문서 속성 모달 */
        .properties-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .properties-modal.show {
            display: flex;
            opacity: 1;
        }

        .properties-dialog {
            background: rgb(41, 42, 45);
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            min-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .properties-modal.show .properties-dialog {
            transform: scale(1);
        }

        .properties-header {
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #555;
        }

        .properties-title {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        .properties-content {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .property-group {
            padding-bottom: 12px;
            margin-bottom: 12px;
            position: relative;
        }

        .property-group:not(:last-child)::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, #666, transparent);
        }

        .property-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .property-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 2px 0;
        }

        .property-label {
            min-width: 140px;
            font-size: 13px;
            color: #ccc;
            flex-shrink: 0;
        }

        .property-value {
            font-size: 13px;
            color: #fff;
            flex: 1;
            word-break: break-all;
        }

        .properties-footer {
            margin-top: 20px;
            padding-top: 12px;
            border-top: 1px solid #555;
            display: flex;
            justify-content: flex-end;
        }

        .properties-close-btn {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .properties-close-btn:hover {
            background: #3367d6;
        }

        /* 사용 방법 모달 */
        .help-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .help-modal.show {
            display: flex;
            opacity: 1;
        }

        .help-dialog {
            background: rgb(41, 42, 45);
            border-radius: 8px;
            padding: 0;
            max-width: 800px;
            min-width: 600px;
            max-height: 85vh;
            color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .help-modal.show .help-dialog {
            transform: scale(1);
        }

        .help-header {
            padding: 20px 24px;
            border-bottom: 1px solid #555;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        .help-title {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            margin: 0;
        }

        .help-close-btn {
            background: transparent;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .help-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px 24px;
            line-height: 1.6;
        }

        .help-section {
            margin-bottom: 24px;
        }

        .help-section:last-child {
            margin-bottom: 0;
        }

        .help-section h3 {
            font-size: 16px;
            font-weight: bold;
            color: #4285f4;
            margin: 0 0 12px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-section ul {
            margin: 0;
            padding-left: 20px;
        }

        .help-section li {
            margin-bottom: 8px;
            color: #ccc;
        }

        .help-section li strong {
            color: #fff;
        }

        .help-section li code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #4285f4;
        }

        .help-footer {
            padding: 16px 24px;
            border-top: 1px solid #555;
            display: flex;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .help-close-btn-footer {
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 8px 20px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .help-close-btn-footer:hover {
            background: #3367d6;
        }

        /* 라이트 테마 지원 */
        body.light-theme .help-dialog {
            background: white;
            color: #202124;
        }

        body.light-theme .help-title {
            color: #202124;
        }

        body.light-theme .help-header {
            border-bottom: 1px solid #e1e5e9;
        }

        body.light-theme .help-close-btn {
            color: #5f6368;
        }

        body.light-theme .help-close-btn:hover {
            background: rgba(60, 64, 67, 0.08);
            color: #202124;
        }

        body.light-theme .help-content {
            color: #202124;
        }

        body.light-theme .help-section li {
            color: #5f6368;
        }

        body.light-theme .help-section li strong {
            color: #202124;
        }

        body.light-theme .help-section li code {
            background: rgba(60, 64, 67, 0.08);
            color: #1a73e8;
        }

        body.light-theme .help-footer {
            border-top: 1px solid #e1e5e9;
        }

        /* 토스트 알림 */
        .toast-container {
            position: fixed;
            top: 20px; /* 기본값: 툴바가 없을 때 */
            right: 20px;
            z-index: 500; /* 1000에서 500으로 변경 */
            pointer-events: none;
            transition: top 0.3s ease, right 0.3s ease; /* right 전환 추가 */
        }

        /* 툴바가 있을 때의 토스트 위치 */
        .toast-container.with-toolbar {
            top: 76px; /* 툴바 높이 + 약간의 여백 */
        }

        /* 드롭다운이 열려있을 때 토스트 위치 조정 */
        .toast-container.dropdown-open {
            right: 220px; /* 드롭다운 너비만큼 왼쪽으로 이동 */
        }

        .toast {
            background: #323232;
            color: white;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 8px;
            transform: translateX(400px);
            transition: all 0.3s ease;
            opacity: 0;
            max-width: 300px;
            word-wrap: break-word;
        }

        .toast-counter {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff4444;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            padding: 0 2px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 1;
        }

        .toast {
            position: relative; /* 카운터 뱃지 위치 기준점 */
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.hide {
            transform: translateX(400px);
            opacity: 0;
        }

        /* 드롭다운 메뉴 */
        .dropdown-container {
            position: relative;
            display: inline-block;
        }

        /* 드롭다운 메뉴 z-index 최고 우선순위 */
        .dropdown-menu {
            position: fixed;
            min-width: 200px;
            background: rgb(50, 50, 50);
            border: 1px solid #666;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 999999999 !important; /* 매우 높은 우선순위 */
            opacity: 0;
            transform: translateY(-10px) scale(0.95);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            overflow: hidden;
            visibility: hidden;
        }

        /* PDF 관련 모든 요소들 z-index 최하위로 */
        .pdf-viewer {
            z-index: -1 !important;
            position: relative;
        }

        .pdf-container {
            z-index: -1 !important;
            position: relative;
        }

        .pdf-wrapper {
            z-index: -1 !important;
            position: relative;
        }

        .pdf-content {
            z-index: -1 !important;
            position: relative;
        }

        #pdfImage {
            z-index: -1 !important;
            position: relative;
        }

        .text-layer {
            z-index: 0 !important; /* 텍스트 선택을 위해 이미지보다만 위에 */
            position: absolute;
        }

        /* 모바일에서 드롭다운 메뉴 추가 스타일 */
        body.mobile-device .pdf-viewer,
        body.mobile-device .pdf-container,
        body.mobile-device .pdf-wrapper,
        body.mobile-device .pdf-content,
        body.mobile-device #pdfImage {
            z-index: -10 !important;
        }

        body.mobile-device .text-layer {
            z-index: -5 !important;
        }

        /* 모바일에서 드롭다운 더 강화 */
        body.mobile-device .dropdown-menu {
            z-index: 9999999999 !important;
            position: fixed !important;
        }

        /* 라이트 테마 드롭다운 */
        body.light-theme .dropdown-menu {
            background: white;
            border: 1px solid #dadce0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 999999999 !important;
        }

        body.light-theme.mobile-device .dropdown-menu {
            z-index: 9999999999 !important;
        }

        .dropdown-menu.show {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: auto;
            visibility: visible; /* 추가: 표시할 때 보이게 */
        }

        .dropdown-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
            position: relative;
        }

        .dropdown-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .dropdown-item.disabled {
            color: #888;
            cursor: not-allowed;
        }

        .dropdown-item.disabled:hover {
            background: transparent;
        }

        .dropdown-item-icon {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .dropdown-item-text {
            flex: 1;
        }

        .dropdown-item-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #4285f4;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .dropdown-item.active .dropdown-item-toggle {
            opacity: 1;
        }

        .dropdown-separator {
            height: 1px;
            background: #666;
            margin: 4px 0;
        }

        /* 로딩 */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ccc;
            font-size: 16px;
        }

        /* 커스텀 확인 모달 */
        .confirm-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .confirm-modal.show {
            display: flex;
            opacity: 1;
        }

        .confirm-dialog {
            background: rgb(41, 42, 45);
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            min-width: 300px;
            color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s ease;
            text-align: center;
        }

        .confirm-modal.show .confirm-dialog {
            transform: scale(1);
        }

        .confirm-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #fff;
        }

        .confirm-message {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 24px;
            color: #ccc;
            white-space: pre-line; /* 이 줄 추가! */
            text-align: center; /* 중앙 정렬 유지 */
        }

        .confirm-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            min-width: 80px;
        }

        .confirm-btn.primary {
            background: #4285f4;
            color: white;
        }

        .confirm-btn.primary:hover {
            background: #3367d6;
        }

        .confirm-btn.secondary {
            background: #666;
            color: white;
        }

        .confirm-btn.secondary:hover {
            background: #777;
        }

        /* 라이트 테마 지원 */
        body.light-theme .confirm-dialog {
            background: white;
            color: #202124;
        }

        body.light-theme .confirm-title {
            color: #202124;
        }

        body.light-theme .confirm-message {
            color: #5f6368;
            white-space: pre-line; /* 이 줄 추가! */
        }

        /* 알림 모달 (확인 버튼만 있는 버전) */
        .alert-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .alert-modal.show {
            display: flex;
            opacity: 1;
        }

        .alert-dialog {
            background: rgb(41, 42, 45);
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            min-width: 300px;
            color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.3s ease;
            text-align: center;
        }

        .alert-modal.show .alert-dialog {
            transform: scale(1);
        }

        .alert-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 16px;
            color: #fff;
        }

        .alert-message {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 24px;
            color: #ccc;
            white-space: pre-line;
            text-align: center;
        }

        .alert-buttons {
            display: flex;
            justify-content: center;
        }

        .alert-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            min-width: 80px;
            background: #4285f4;
            color: white;
        }

        .alert-btn:hover {
            background: #3367d6;
        }

        /* 라이트 테마 - 알림 모달 */
        body.light-theme .alert-dialog {
            background: white;
            color: #202124;
        }

        body.light-theme .alert-title {
            color: #202124;
        }

        body.light-theme .alert-message {
            color: #5f6368;
            white-space: pre-line;
        }

        /* PDF 관련 요소들만 낮은 z-index */
        .pdf-viewer,
        .pdf-container,
        .pdf-wrapper,
        .pdf-content,
        #pdfImage {
            z-index: 1;
        }

        .text-layer {
            z-index: 2; /* 텍스트 선택용 */
        }
    </style>
</head>
<body>
    <!-- 모바일 백드롭 -->
    <div class="mobile-backdrop" id="mobileBackdrop"></div>

    <!-- 상단 툴바 -->
    <div class="toolbar" id="toolbar" style="display: none;">
        <div class="toolbar-section left">
            <button class="toolbar-btn" id="sidebarToggle" title="사이드바 열기/닫기 (Ctrl+B)">☰</button>
            <span class="file-title" id="fileTitle">PDF 파일</span>
        </div>

        <div class="toolbar-section center">
            <input type="number" class="toolbar-input" id="pageInput" min="1" value="1">
            <span class="page-divider">/ <span id="totalPages">1</span></span>
            <div class="toolbar-divider">|</div>
            <button class="toolbar-btn" id="zoomOut" title="축소 (Ctrl+-)">-</button>
            <select class="zoom-select" id="zoomSelect">
                <!-- 옵션들은 JavaScript에서 동적으로 생성 -->
            </select>
            <button class="toolbar-btn" id="zoomIn" title="확대 (Ctrl++)">+</button>
            <div class="toolbar-divider">|</div>
            <button class="toolbar-btn fit-toggle-btn" id="fitToggleBtn" title="페이지 맞춤 / 너비 맞춤 전환">↕️</button>
            <button class="toolbar-btn" id="copyBtn" title="스마트 복사 (Ctrl+C)">📋</button>
            <button class="toolbar-btn" id="captureBtn" title="영역 캡쳐 (Ctrl+Shift+X)">✂️</button>
        </div>

        <div class="toolbar-section right">
            <button class="toolbar-btn" id="themeToggleBtn" title="다크모드">🌙</button>
            <div class="dropdown-container">
                <button class="toolbar-btn" id="propertiesBtn" title="더보기">⋮</button>
                <div class="dropdown-menu" id="dropdownMenu">
                    <div class="dropdown-item disabled" id="dualPageItem">
                        <div class="dropdown-item-icon">📖</div>
                        <div class="dropdown-item-text">두 페이지씩 보기</div>
                        <div class="dropdown-item-toggle">✓</div>
                    </div>
                    <div class="dropdown-item" id="autoTrackItem">
                        <div class="dropdown-item-icon">📋</div>
                        <div class="dropdown-item-text">자동 복사</div>
                        <div class="dropdown-item-toggle">✓</div>
                    </div>
                    <div class="dropdown-item" id="toastToggleItem">
                        <div class="dropdown-item-icon">💬</div>
                        <div class="dropdown-item-text">토스트 메시지</div>
                        <div class="dropdown-item-toggle">✓</div>
                    </div>
                    <div class="dropdown-separator"></div>
                    <div class="dropdown-item disabled" id="presentationItem">
                        <div class="dropdown-item-icon">🎞️</div>
                        <div class="dropdown-item-text">발표</div>
                        <div class="dropdown-item-toggle"></div>
                    </div>
                    <div class="dropdown-separator"></div>
                    <!-- 여기에 사용 방법 항목 추가 -->
                    <div class="dropdown-item" id="helpItem">
                        <div class="dropdown-item-icon">❓</div>
                        <div class="dropdown-item-text">사용 방법</div>
                        <div class="dropdown-item-toggle"></div>
                    </div>
                    <div class="dropdown-item" id="documentPropertiesItem">
                        <div class="dropdown-item-icon">ℹ️</div>
                        <div class="dropdown-item-text">문서 속성</div>
                        <div class="dropdown-item-toggle"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 메인 레이아웃 -->
    <div class="main-layout">
        <!-- 사이드바 -->
        <div class="sidebar" id="sidebar">
            <!-- 아이콘 패널 -->
            <div class="icon-panel">
                <button class="icon-btn" id="folderBtn" title="폴더 탐색기">📁</button>
                <button class="icon-btn" id="thumbnailsBtn" title="페이지 썸네일" disabled>🖼️</button>
            </div>
            
            <!-- 썸네일 섹션 -->
            <div class="thumbnails-section">
                <div class="thumbnails-container" id="thumbnailsContainer">
                    <div class="loading-thumbnails" id="loadingThumbnails">
                        PDF를 로드해주세요
                    </div>
                </div>
            </div>

            <!-- 폴더 탐색기 섹션 -->
            <div class="folder-section">
                <div class="folder-header">
                    <span class="folder-title" id="folderTitle">📁 폴더 탐색기</span>
                    <button class="folder-select-btn" id="selectFolderBtn">폴더 선택</button>
                </div>
                <div class="folder-tree" id="folderTree">
                    <div class="folder-empty" id="folderEmptyArea">📁 폴더를 선택하거나 PDF 파일들을 여기로 드래그하세요</div>
                </div>
            </div>
        </div>

        <!-- 메인 콘텐츠 영역 -->
        <div class="main-content" id="mainContent">
            <!-- 파일 입력 요소들 (uploadArea 밖으로 이동) -->
            <input type="file" class="file-input" id="fileInput" accept=".pdf">
            <input type="file" class="file-input" id="folderInput" webkitdirectory directory multiple>
            
            <!-- 업로드 영역 -->
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <div class="upload-text" id="uploadText">폴더를 선택하세요</div>
                <button class="upload-btn" id="uploadBtn">폴더 선택</button>
                <div style="margin-top: 20px; text-align: center; color: #888; font-size: 14px; line-height: 1.6;" id="usageGuide">
                    <strong style="color: #ccc;">시작하기:</strong><br>
                    <strong style="color: #4285f4;">• 데스크톱:</strong> <strong>폴더 선택 버튼</strong>으로 PDF 파일들이 있는 폴더를 선택하세요<br>
                    <strong style="color: #4285f4;">• 모바일:</strong> <strong>파일 선택 버튼</strong>으로 개별 PDF 파일을 선택하세요<br>
                    <strong style="color: #4285f4;">• 드래그 앤 드롭:</strong> PDF 파일들을 직접 끌어다 놓으세요
                </div>
            </div>

            <!-- 폴더 선택 완료 메시지 -->
            <div class="folder-selected-message" id="folderSelectedMessage" style="display: none;">
                <div class="folder-selected-icon">📂</div>
                <div class="folder-selected-text">폴더가 선택되었습니다!</div>
                <div class="folder-selected-subtitle">
                    왼쪽 폴더 탐색기에서 PDF 파일을 클릭하여 열어보세요.<br>
                    📁 폴더 아이콘을 클릭하면 폴더 탐색기를 열 수 있습니다.
                </div>
            </div>

            <!-- PDF 뷰어 -->
            <div class="pdf-viewer" id="pdfViewer">
                <div class="pdf-container" id="pdfContainer">
                    <div class="pdf-wrapper" id="pdfWrapper">
                        <div class="pdf-content" id="pdfContent">
                            <img id="pdfImage" alt="PDF Page">
                            <canvas id="pdfCanvas"></canvas>
                            <div class="text-layer" id="textLayer"></div>
                            <div class="capture-overlay" id="captureOverlay">
                                <div class="capture-guide" id="captureGuide">드래그하여 캡쳐할 영역을 선택하세요 (ESC: 종료)</div>
                                <div class="selection-area" id="selectionArea"></div>
                            </div>
                        </div>
                    </div>
                    <div class="loading" id="loading" style="display: none;">로딩중...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 썸네일 창 모달 -->
    <div class="thumbnail-window-modal" id="thumbnailWindowModal">
        <div class="thumbnail-window">
            <div class="thumbnail-window-header">
                <button class="thumbnail-window-close" id="thumbnailWindowClose">✕</button>
                <div class="thumbnail-window-title">
                    축소판
                </div>
                <button class="thumbnail-window-select-toggle" id="thumbnailSelectToggle">☑️</button>
            </div>
            <div class="thumbnail-window-content">
                <div class="thumbnail-window-grid" id="thumbnailWindowGrid">
                    <!-- 썸네일들이 동적으로 여기에 추가됩니다 -->
                </div>
            </div>
        </div>
    </div>

    <!-- 문서 속성 모달 -->
    <div class="properties-modal" id="propertiesModal">
        <div class="properties-dialog">
            <div class="properties-header">
                <h2 class="properties-title">문서 속성</h2>
            </div>
            <div class="properties-content" id="propertiesContent">
                <!-- 속성들이 동적으로 여기에 추가됩니다 -->
            </div>
            <div class="properties-footer">
                <button class="properties-close-btn" id="propertiesCloseBtnFooter">닫기</button>
            </div>
        </div>
    </div>

    <!-- 사용 방법 모달 -->
    <div class="help-modal" id="helpModal">
        <div class="help-dialog">
            <div class="help-header">
                <h2 class="help-title">사용 방법</h2>
                <button class="help-close-btn" id="helpCloseBtn">✕</button>
            </div>
            <div class="help-content" id="helpContent">
                <!-- 내용은 JavaScript에서 동적으로 생성 -->
            </div>
            <div class="help-footer">
                <button class="help-close-btn-footer" id="helpCloseBtnFooter">닫기</button>
            </div>
        </div>
    </div>

    <!-- 확인 모달 -->
    <div class="confirm-modal" id="confirmModal">
        <div class="confirm-dialog">
            <div class="confirm-title" id="confirmTitle">확인</div>
            <div class="confirm-message" id="confirmMessage">작업을 진행하시겠습니까?</div>
            <div class="confirm-buttons">
                <button class="confirm-btn secondary" id="confirmCancel">취소</button>
                <button class="confirm-btn primary" id="confirmOk">확인</button>
            </div>
        </div>
    </div>

    <!-- 알림 모달 -->
    <div class="alert-modal" id="alertModal">
        <div class="alert-dialog">
            <div class="alert-title" id="alertTitle">알림</div>
            <div class="alert-message" id="alertMessage">메시지가 여기에 표시됩니다.</div>
            <div class="alert-buttons">
                <button class="alert-btn" id="alertOk">확인</button>
            </div>
        </div>
    </div>

    <!-- 토스트 알림 컨테이너 -->
    <div class="toast-container" id="toastContainer">
    </div>

    <script>
        // PDF.js 워커 설정
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        class PDFClipboard {
            constructor() {
                this.pdf = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.scale = 1.0;
                this.fitMode = 'none'; // 'width', 'page', 'none'
                this.currentFile = null; // 현재 파일 객체 저장
                
                // 성능 최적화된 렌더링 설정
                this.pixelRatio = window.devicePixelRatio || 1;
                this.renderScale = 3.0; // 고품질 렌더링 스케일
                
                // 원본 페이지 크기 저장 (중요!)
                this.originalPageWidth = 0;
                this.originalPageHeight = 0;
                
                // 렌더링 작업 관리
                this.currentRenderTask = null;
                
                // 디바운스 타이머들
                this.textLayerTimeout = null;
                this.isZooming = false;
                
                // 캡쳐 기능 관련
                this.isCaptureMode = false;
                this.isSelecting = false;
                this.selectionStart = { x: 0, y: 0 };
                this.selectionEnd = { x: 0, y: 0 };
                
                // 터치/스와이프 관련
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchStartTime = 0;
                this.isTouch = false;
                this.swipeThreshold = 50; // 스와이프 최소 거리
                this.swipeTimeThreshold = 300; // 스와이프 최대 시간 (ms)
                
                // 사이드바 관련
                this.isIconPanelOpen = false;
                this.isThumbnailsOpen = false;
                this.isFolderOpen = false;
                this.currentSidebarType = 'thumbnails'; // 'thumbnails' or 'folder'
                
                // 모바일 감지
                this.isMobile = this.detectMobile();
                
                // 모바일이면 썸네일, 데스크톱이면 폴더가 기본
                this.lastOpenedSidebarType = this.isMobile ? 'thumbnails' : 'folder';
                this.thumbnails = [];
                this.folderStructure = null;
                this.currentFolder = null;
                this.selectedFile = null;
                this.currentFolderName = null; // 폴더명 저장
                
                // 새로운 기능들
                this.isAutoTrackEnabled = false; // 자동 추적(복사) 기능 - 기본값 false로 변경
                this.isDualPageEnabled = false; // 두 페이지씩 보기
                this.isDropdownOpen = false; // 드롭다운 메뉴 상태
                this.isToastEnabled = true; // 토스트 메시지 표시 여부 - 기본값 true
                
                // 썸네일 창 관련
                this.isThumbnailWindowOpen = false; // 썸네일 창 열림 상태
                this.thumbnailMode = 'none'; // 'none', 'sidebar', 'window'
                
                // 다중 선택 관련 (기존 변수들에 추가)
                this.isSelectionMode = false; // 선택 모드 활성화 여부
                this.selectedPages = new Set(); // 선택된 페이지들
                this.lastSelectedPage = null; // 마지막으로 선택된 페이지 (범위 선택용)

                this.initElements();
                this.initializeZoomSelect();
                this.bindEvents();
                this.setupMobileUI();
                this.applyDeviceClass(); // 이 줄 추가
                this.initializeTheme();
                
                // 초기 상태에서 썸네일 버튼 비활성화
                this.thumbnailsBtn.disabled = true;

                this.activeToasts = new Map(); // 활성 토스트 관리용

                this.isPageTransitioning = false; // 페이지 이동 중 플래그
            }

            // 커스텀 알림 모달 표시 (확인 버튼만)
            showAlertModal(title, message) {
                return new Promise((resolve) => {
                    const modal = document.getElementById('alertModal');
                    const titleEl = document.getElementById('alertTitle');
                    const messageEl = document.getElementById('alertMessage');
                    const okBtn = document.getElementById('alertOk');
                    
                    titleEl.textContent = title;
                    messageEl.textContent = message;
                    
                    // 모달 표시
                    modal.style.display = 'flex';
                    setTimeout(() => modal.classList.add('show'), 10);
                    
                    // 이벤트 핸들러 (한 번만 실행)
                    const handleOk = () => {
                        this.hideAlertModal();
                        cleanup();
                        resolve(true);
                    };
                    
                    const cleanup = () => {
                        okBtn.removeEventListener('click', handleOk);
                    };
                    
                    okBtn.addEventListener('click', handleOk);
                    
                    // ESC 키로 닫기
                    const handleKeydown = (e) => {
                        if (e.key === 'Escape') {
                            handleOk();
                            document.removeEventListener('keydown', handleKeydown);
                        }
                    };
                    document.addEventListener('keydown', handleKeydown);
                    
                    // 모달 외부 클릭으로 닫기
                    const handleModalClick = (e) => {
                        if (e.target === modal) {
                            handleOk();
                            modal.removeEventListener('click', handleModalClick);
                        }
                    };
                    modal.addEventListener('click', handleModalClick);
                });
            }

            // 커스텀 알림 모달 숨기기
            hideAlertModal() {
                const modal = document.getElementById('alertModal');
                modal.classList.remove('show');
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }

            // 드롭다운 메뉴 토글
            toggleDropdown() {
                this.isDropdownOpen = !this.isDropdownOpen;
                
                if (this.isDropdownOpen) {
                    this.showDropdown();
                } else {
                    this.hideDropdown();
                }
            }

            // 드롭다운 메뉴 표시
            showDropdown() {
                this.isDropdownOpen = true;
                this.updateDropdownStates();
                
                // 버튼의 위치를 계산해서 드롭다운 위치 설정
                const buttonRect = this.propertiesBtn.getBoundingClientRect();
                
                // 모바일에서는 특별한 위치 조정
                if (this.isMobile) {
                    // 모바일에서는 화면 우측 상단에 고정 위치
                    const rightOffset = 8;
                    const topOffset = buttonRect.bottom + 8;
                    
                    this.dropdownMenu.style.left = 'auto';
                    this.dropdownMenu.style.right = rightOffset + 'px';
                    this.dropdownMenu.style.top = topOffset + 'px';
                } else {
                    // 데스크톱에서는 기존 로직
                    const rightOffset = 8;
                    const topOffset = 8;
                    
                    let left = buttonRect.right - 200;
                    let top = buttonRect.bottom + topOffset;
                    
                    if (left < rightOffset) {
                        left = rightOffset;
                    }
                    
                    if (left + 200 > window.innerWidth - rightOffset) {
                        left = window.innerWidth - 200 - rightOffset;
                    }
                    
                    if (top + 300 > window.innerHeight - 20) {
                        top = buttonRect.top - 300 - topOffset;
                    }
                    
                    this.dropdownMenu.style.left = left + 'px';
                    this.dropdownMenu.style.right = 'auto';
                    this.dropdownMenu.style.top = top + 'px';
                    this.dropdownMenu.style.zIndex = '999999';
                }
                
                this.dropdownMenu.style.visibility = 'visible';
                
                // 토스트 위치 조정
                this.toastContainer.classList.add('dropdown-open');
                
                // 브라우저가 위치를 적용한 후 애니메이션 시작
                requestAnimationFrame(() => {
                    this.dropdownMenu.classList.add('show');
                });
            }

            // 드롭다운 메뉴 숨기기
            hideDropdown() {
                this.isDropdownOpen = false;
                this.dropdownMenu.classList.remove('show');
                
                // 토스트 위치 복원 - 여기에 추가
                this.toastContainer.classList.remove('dropdown-open');
                
                // 애니메이션 완료 후 완전히 숨김
                setTimeout(() => {
                    if (!this.isDropdownOpen) {
                        this.dropdownMenu.style.visibility = 'hidden';
                    }
                }, 300); // transition 시간과 일치
            }

            // 드롭다운 상태 업데이트
            updateDropdownStates() {
                // 두 페이지씩 보기는 항상 비활성화 상태 (개발 중)
                this.dualPageItem.classList.remove('active');
                
                // 자동 추적 상태 업데이트
                if (this.isAutoTrackEnabled) {
                    this.autoTrackItem.classList.add('active');
                } else {
                    this.autoTrackItem.classList.remove('active');
                }
                
                // 토스트 메시지 상태 업데이트
                if (this.isToastEnabled) {
                    this.toastToggleItem.classList.add('active');
                } else {
                    this.toastToggleItem.classList.remove('active');
                }
            }

            // 자동 추적 토글
            toggleAutoTrack() {
                this.isAutoTrackEnabled = !this.isAutoTrackEnabled;
                this.updateDropdownStates();
                
                if (this.isAutoTrackEnabled) {
                    this.showToastMessage('📋 자동 복사 활성화: 페이지 이동 시 자동으로 복사됩니다'); // 수정
                } else {
                    this.showToastMessage('🚫 자동 복사 비활성화: 자동 복사가 중지되었습니다'); // 수정
                }
                
                this.hideDropdown();
            }

            // 토스트 메시지 토글
            toggleToastMessages() {
                this.isToastEnabled = !this.isToastEnabled;
                this.updateDropdownStates();
                
                if (this.isToastEnabled) {
                    this.showToastMessage('💬 토스트 메시지가 활성화되었습니다');
                } else {
                    // 토스트가 비활성화되면 마지막 메시지만 강제로 표시
                    this.showToastMessage('🔇 토스트 메시지가 비활성화되었습니다', true);
                }
                
                this.hideDropdown();
            }

            // 자동 추적 실행 (페이지 이동 시 호출)
            async performAutoTrack() {
                if (!this.isAutoTrackEnabled || !this.pdf) return;
                
                try {
                    // 자동 추적은 항상 이미지로 복사
                    await this.copyImageToClipboard();
                    // 토스트 메시지는 copyImageToClipboard에서 이미 표시됨
                } catch (error) {
                    console.error('자동 복사 실패:', error);
                }
            }

            // 모바일 감지 함수 - 실제 디바이스만 감지, 창 크기는 제외
            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            // 모바일 UI 설정
            setupMobileUI() {
                if (this.isMobile) {
                    // 모바일: 파일 선택 텍스트로 변경
                    document.getElementById('uploadText').textContent = '파일을 선택하세요';
                    document.getElementById('uploadBtn').textContent = '파일 선택';
                    document.getElementById('folderTitle').textContent = '📁 파일 선택';
                    document.getElementById('selectFolderBtn').textContent = '파일 선택';
                    
                    // 빈 영역 텍스트도 모바일용으로 변경
                    const folderEmptyArea = document.getElementById('folderEmptyArea');
                    if (folderEmptyArea) {
                        folderEmptyArea.textContent = '📁 파일을 선택하거나 PDF 파일들을 여기로 드래그하세요';
                    }
                } else {
                    // 데스크톱: 폴더 선택 텍스트로 변경
                    document.getElementById('uploadText').textContent = '폴더를 선택하세요';
                    document.getElementById('uploadBtn').textContent = '폴더 선택';
                    document.getElementById('selectFolderBtn').textContent = '폴더 선택';
                    
                    // **핵심 수정: 폴더명 복원 로직**
                    this.updateFolderTitle(this.currentFolderName);
                    
                    // 빈 영역 텍스트도 데스크톱용으로 변경
                    const folderEmptyArea = document.getElementById('folderEmptyArea');
                    if (folderEmptyArea) {
                        folderEmptyArea.textContent = '📁 폴더를 선택하거나 PDF 파일들을 여기로 드래그하세요';
                    }
                }
                
                // 공통 설정 - 간단한 사용법만 표시
                const usageGuide = document.getElementById('usageGuide');
                if (usageGuide) {
                    // 기존 스타일 수정
                    usageGuide.style.textAlign = 'center';
                    usageGuide.style.maxWidth = '450px';
                    usageGuide.style.margin = '20px auto 0 auto';
                    
                    usageGuide.innerHTML = `
                        <div style="text-align: left; padding-left: 20px;">
                            <div style="margin-bottom: 8px; line-height: 1.5;">
                                <strong style="color: #4285f4;">• ${this.isMobile ? '모바일2' : '데스크톱1'}:</strong> <strong>${this.isMobile ? '파일' : '폴더'} 선택 버튼</strong>으로 ${this.isMobile ? '개별 PDF 파일을' : 'PDF 파일들이 있는 폴더를'} 선택하세요
                            </div>
                            <div style="margin-bottom: 8px; line-height: 1.5;">
                                <strong style="color: #4285f4;">• 드래그 앤 드롭:</strong> PDF 파일들을 직접 끌어다 놓으세요
                            </div>
                            <div style="line-height: 1.5;">
                                <strong style="color: #4285f4;">• 자세한 사용법:</strong> PDF를 열고 <strong>⋮ 메뉴 → 사용 방법</strong>에서 확인하세요
                            </div>
                        </div>
                    `;
                }
            }
            
            // 반응형 UI 감지 (창 크기 기반)
            detectResponsiveMode() {
                return window.innerWidth <= 768;
            }

            // 반응형 사이드바 처리
            handleResponsiveSidebar() {
                // 실제 모바일 디바이스가 아닌 경우에만 반응형 처리
                if (this.isMobile) return;
                
                const isNarrowScreen = this.detectResponsiveMode();
                
                // PC에서 좁은 화면일 때의 처리 (필요시)
                if (isNarrowScreen) {
                    // PC에서 창이 좁을 때의 특별한 처리가 필요하면 여기에 추가
                    console.log('PC 좁은 화면 모드');
                }
            }

            initializeZoomSelect() {
                const defaultOptions = [25, 50, 75, 100, 125, 150, 200, 300, 400, 500];
                this.zoomSelect.innerHTML = '';
                
                defaultOptions.forEach(zoom => {
                    const option = document.createElement('option');
                    option.value = zoom;
                    option.textContent = zoom + '%';
                    if (zoom === 100) {
                        option.selected = true;
                    }
                    this.zoomSelect.appendChild(option);
                });
                
                // 초기 배율 선택 박스 크기 설정
                this.updateZoomSelectWidth();
            }

            initElements() {
                this.uploadArea = document.getElementById('uploadArea');
                this.fileInput = document.getElementById('fileInput');
                this.toolbar = document.getElementById('toolbar');
                this.pdfViewer = document.getElementById('pdfViewer');
                this.pdfContainer = document.getElementById('pdfContainer');
                this.pdfWrapper = document.getElementById('pdfWrapper');
                this.pdfContent = document.getElementById('pdfContent');
                this.pdfImage = document.getElementById('pdfImage'); // 이미지 요소
                this.canvas = document.getElementById('pdfCanvas'); // 숨겨진 캔버스 (렌더링용)
                this.ctx = this.canvas.getContext('2d');
                this.textLayer = document.getElementById('textLayer');
                this.pageInput = document.getElementById('pageInput');
                this.totalPagesSpan = document.getElementById('totalPages');
                this.zoomIn = document.getElementById('zoomIn');
                this.zoomOut = document.getElementById('zoomOut');
                this.zoomSelect = document.getElementById('zoomSelect');
                this.fitToggleBtn = document.getElementById('fitToggleBtn');
                this.copyBtn = document.getElementById('copyBtn');
                this.captureBtn = document.getElementById('captureBtn');
                this.sidebarToggle = document.getElementById('sidebarToggle');
                this.fileTitle = document.getElementById('fileTitle');
                this.toastContainer = document.getElementById('toastContainer');
                this.loading = document.getElementById('loading');
                this.folderSelectedMessage = document.getElementById('folderSelectedMessage');
                
                // 새로운 UI 요소들
                this.mainContent = document.getElementById('mainContent');
                this.sidebar = document.getElementById('sidebar');
                this.thumbnailsBtn = document.getElementById('thumbnailsBtn');
                this.folderBtn = document.getElementById('folderBtn');
                this.thumbnailsContainer = document.getElementById('thumbnailsContainer');
                this.loadingThumbnails = document.getElementById('loadingThumbnails');
                this.folderInput = document.getElementById('folderInput');
                this.selectFolderBtn = document.getElementById('selectFolderBtn');
                this.folderTree = document.getElementById('folderTree');
                this.folderTitle = document.getElementById('folderTitle'); // 폴더 제목 요소 추가
                this.mobileBackdrop = document.getElementById('mobileBackdrop'); // 모바일 백드롭
                
                // 캡쳐 관련 요소들
                this.captureOverlay = document.getElementById('captureOverlay');
                this.captureGuide = document.getElementById('captureGuide');
                this.selectionArea = document.getElementById('selectionArea');
                
                // 문서 속성 관련 요소들
                this.propertiesBtn = document.getElementById('propertiesBtn');
                this.propertiesModal = document.getElementById('propertiesModal');
                this.propertiesCloseBtnFooter = document.getElementById('propertiesCloseBtnFooter');
                this.propertiesContent = document.getElementById('propertiesContent');
                
                // 드롭다운 메뉴 관련 요소들
                this.dropdownMenu = document.getElementById('dropdownMenu');
                this.dualPageItem = document.getElementById('dualPageItem');
                this.autoTrackItem = document.getElementById('autoTrackItem');
                this.toastToggleItem = document.getElementById('toastToggleItem');
                this.presentationItem = document.getElementById('presentationItem');
                this.documentPropertiesItem = document.getElementById('documentPropertiesItem');
                
                // 테마 토글 관련 요소들
                this.themeToggleBtn = document.getElementById('themeToggleBtn');
                this.currentTheme = 'dark'; // 'dark', 'light', 'system'
                
                // 썸네일 창 관련 요소들
                this.thumbnailWindowModal = document.getElementById('thumbnailWindowModal');
                this.thumbnailWindowClose = document.getElementById('thumbnailWindowClose');
                this.thumbnailWindowGrid = document.getElementById('thumbnailWindowGrid');
                this.thumbnailSelectToggle = document.getElementById('thumbnailSelectToggle');

                // 기존 요소들 뒤에 추가
                this.helpItem = document.getElementById('helpItem');
                this.helpModal = document.getElementById('helpModal');
                this.helpCloseBtn = document.getElementById('helpCloseBtn');
                this.helpCloseBtnFooter = document.getElementById('helpCloseBtnFooter');
                this.helpContent = document.getElementById('helpContent');
            }
            
            // 모바일 디바이스 클래스 적용
            applyDeviceClass() {
                if (this.isMobile) {
                    document.body.classList.add('mobile-device');
                } else {
                    document.body.classList.remove('mobile-device');
                }
            }

            // PDF를 항상 중앙에 유지하는 헬퍼 함수
            maintainPDFCenter() {
                if (!this.pdf || !this.pdfImage.src) return;
    
                // 페이지 이동 중에는 중앙 정렬 하지 않음
                if (this.isPageTransitioning) {
                    console.log('페이지 이동 중이므로 maintainPDFCenter 스킵');
                    return;
                }
                
                // 추가: 페이지 이동 속성이 있는 동안에도 스킵
                if (this.pdfContainer.hasAttribute('data-page-transitioning') || 
                    this.pdfWrapper.hasAttribute('data-page-transitioning')) {
                    console.log('페이지 이동 속성으로 인해 maintainPDFCenter 스킵');
                    return;
                }
                
                // **핵심 추가: 맞춤 모드에서는 maintainPDFCenter 실행하지 않음**
                if (this.fitMode === 'width' || this.fitMode === 'page') {
                    console.log('맞춤 모드에서는 maintainPDFCenter 스킵:', this.fitMode);
                    return;
                }
                
                // 이미 실행 중이면 중복 실행 방지
                if (this._maintainingCenter) return;
                this._maintainingCenter = true;
                
                // 다음 프레임에서 실행
                requestAnimationFrame(() => {
                    const container = this.pdfContainer;
                    const wrapper = this.pdfWrapper;
                    
                    // PDF 컨테이너의 실제 가시 영역 계산
                    const mainContentRect = this.mainContent.getBoundingClientRect();
                    const containerWidth = mainContentRect.width;
                    const containerHeight = mainContentRect.height;
                    
                    const pdfWidth = this.originalPageWidth * this.scale;
                    const pdfHeight = this.originalPageHeight * this.scale;
                    
                    console.log('=== maintainPDFCenter 실행 ===');
                    console.log('사이드바 열림:', this.isIconPanelOpen);
                    console.log('실제 가용 너비:', containerWidth);
                    console.log('PDF 너비:', pdfWidth);
                    console.log('PDF 높이:', pdfHeight);
                    console.log('컨테이너 높이:', containerHeight);
                    console.log('현재 스크롤:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                    
                    // PDF가 컨테이너보다 작으면 중앙 정렬 (하지만 높이는 고정하지 않음)
                    if (pdfWidth <= containerWidth) {
                        // wrapper 너비만 100%로 설정, 높이는 건드리지 않음
                        wrapper.style.width = '100%';
                        wrapper.style.display = 'flex';
                        wrapper.style.justifyContent = 'center';
                        
                        // **핵심 변경: 높이는 절대 100%로 설정하지 않음**
                        // wrapper.style.height = '100%'; // 이 줄 제거!
                        
                        // 세로 정렬은 PDF가 컨테이너보다 작을 때만 중앙 정렬
                        if (pdfHeight < containerHeight) {
                            // PDF가 세로로도 작을 때만 중앙 정렬
                            wrapper.style.alignItems = 'center';
                            wrapper.style.minHeight = containerHeight + 'px';
                            console.log('PDF가 세로로 작아서 중앙 정렬 적용');
                        } else {
                            // PDF가 세로로 크면 상단 정렬
                            wrapper.style.alignItems = 'flex-start';
                            wrapper.style.minHeight = 'unset';
                            console.log('PDF가 세로로 커서 상단 정렬 적용');
                        }
                        
                        // 스크롤 초기화는 가로만 (세로는 유지)
                        const currentScrollTop = container.scrollTop;
                        container.scrollLeft = 0;
                        console.log('가로 스크롤만 초기화, 세로 스크롤 유지:', currentScrollTop);
                    } else {
                        // PDF가 가로로 크면 스크롤 가능하게
                        const margin = 20;
                        const wrapperWidth = pdfWidth + margin * 2;
                        const wrapperHeight = Math.max(pdfHeight + margin * 2, containerHeight);
                        
                        wrapper.style.width = wrapperWidth + 'px';
                        wrapper.style.height = wrapperHeight + 'px';
                        wrapper.style.display = 'flex';
                        wrapper.style.justifyContent = 'center';
                        wrapper.style.alignItems = pdfHeight < containerHeight ? 'center' : 'flex-start';
                        wrapper.style.minHeight = 'unset';
                        
                        // 가로 스크롤을 중앙으로
                        const scrollLeft = (wrapperWidth - containerWidth) / 2;
                        container.scrollLeft = Math.max(0, scrollLeft);
                        console.log('가로 스크롤 중앙 정렬:', scrollLeft);
                    }
                    
                    this._maintainingCenter = false;
                });
            }

            // 사이드바 토글 시 PDF 재조정
            async handleSidebarToggle() {
                // 페이지 이동 중이면 사이드바 조정 지연
                if (this.isPageTransitioning) {
                    setTimeout(() => this.handleSidebarToggle(), 100);
                    return;
                }

                if (!this.pdf || this.isMobile) return;
                
                // 사이드바 열기/닫기에 따른 대기 시간
                const waitTime = this.isIconPanelOpen ? 400 : 280;
                await new Promise(resolve => setTimeout(resolve, waitTime));
                
                // 맞춤 모드에 따라 처리
                if (this.fitMode === 'width' || this.fitMode === 'page') {
                    // 너비/페이지 맞춤 모드: 새로운 컨테이너 크기에 맞게 재계산 및 재렌더링
                    const page = await this.pdf.getPage(this.currentPage);
                    
                    if (this.fitMode === 'width') {
                        await this.calculateFitToWidth(page);
                    } else {
                        await this.calculateFitToPage(page);
                    }
                    
                    // 재렌더링
                    await this.renderPage();
                    
                    // 렌더링 후 UI 업데이트
                    this.updateUI();
                    this.updateFitToggle();
                    
                    // 스크롤 위치 리셋
                    this.resetScrollPosition();
                    
                    // 너비 맞춤 모드에서 추가 업데이트
                    if (this.fitMode === 'width') {
                        setTimeout(() => {
                            this.forceUpdateScrollAreaForWidthFit();
                        }, 100);
                    }
                } else {
                    // 기본 모드: 중앙 정렬만
                    this.maintainPDFCenter();
                }
            }

            // 스크롤 위치를 적절히 리셋하는 함수
            resetScrollPosition() {
                const container = this.pdfContainer;
                
                // 너비 맞춤 모드에서는 특별 처리
                if (this.fitMode === 'width') {
                    // 가로 스크롤은 항상 0 (너비에 맞춰져 있으므로)
                    container.scrollLeft = 0;
                    
                    // 스크롤 영역 강제 업데이트
                    this.forceUpdateScrollAreaForWidthFit();
                    
                    // 업데이트 후 세로 스크롤 범위 재확인
                    setTimeout(() => {
                        const maxScrollTop = container.scrollHeight - container.clientHeight;
                        if (container.scrollTop > maxScrollTop && maxScrollTop >= 0) {
                            container.scrollTop = maxScrollTop;
                        }
                    }, 50);
                    
                } else if (this.fitMode === 'page') {
                    // 페이지 맞춤에서는 스크롤 없음
                    container.scrollLeft = 0;
                    container.scrollTop = 0;
                } else {
                    // 기본 모드에서는 중앙 유지
                    this.maintainPDFCenter();
                }
            }

            // 너비 맞춤 모드에서 스크롤 영역 강제 업데이트
            forceUpdateScrollAreaForWidthFit() {
                if (this.fitMode !== 'width') return;
                
                console.log('=== forceUpdateScrollAreaForWidthFit 상세 디버깅 시작 ===');
                
                const container = this.pdfContainer;
                const pdfHeight = this.originalPageHeight * this.scale;
                const containerHeight = container.clientHeight;
                const margin = 20;
                
                console.log('기본 정보:', {
                    pdfHeight,
                    containerHeight,
                    scale: this.scale,
                    originalPageHeight: this.originalPageHeight,
                    margin
                });
                
                // wrapper 설정 전 현재 상태 로깅
                console.log('설정 전 wrapper 스타일:', {
                    width: this.pdfWrapper.style.width,
                    height: this.pdfWrapper.style.height,
                    alignItems: this.pdfWrapper.style.alignItems,
                    padding: this.pdfWrapper.style.padding
                });
                
                // wrapper 설정을 명확히 함
                this.pdfWrapper.style.boxSizing = 'content-box';
                this.pdfWrapper.style.width = '100%';
                this.pdfWrapper.style.height = 'auto';
                this.pdfWrapper.style.minHeight = Math.max(pdfHeight + margin * 2, containerHeight) + 'px';
                this.pdfWrapper.style.padding = `${margin}px 0`;
                this.pdfWrapper.style.display = 'flex';
                this.pdfWrapper.style.justifyContent = 'center';
                
                // **핵심 수정: PDF 높이에 따른 정렬 조건부 설정**
                const shouldCenter = pdfHeight < containerHeight;
                console.log('중앙 정렬 판단:', {
                    pdfHeight,
                    containerHeight,
                    shouldCenter,
                    heightDifference: containerHeight - pdfHeight
                });
                
                if (shouldCenter) {
                    // PDF가 컨테이너보다 작으면 중앙 정렬
                    this.pdfWrapper.style.alignItems = 'center';
                    console.log('✓ PDF가 작아서 중앙 정렬 적용');
                } else {
                    // PDF가 컨테이너보다 크면 상단 정렬
                    this.pdfWrapper.style.alignItems = 'flex-start';
                    console.log('✓ PDF가 커서 상단 정렬 적용');
                }
                
                // **PDF 콘텐츠 margin 초기화**
                this.pdfContent.style.margin = '0';
                this.pdfContent.style.marginTop = '0';
                this.pdfContent.style.marginBottom = '0';
                
                console.log('설정 후 wrapper 스타일:', {
                    width: this.pdfWrapper.style.width,
                    height: this.pdfWrapper.style.height,
                    minHeight: this.pdfWrapper.style.minHeight,
                    alignItems: this.pdfWrapper.style.alignItems,
                    justifyContent: this.pdfWrapper.style.justifyContent,
                    padding: this.pdfWrapper.style.padding,
                    boxSizing: this.pdfWrapper.style.boxSizing
                });
                
                // 강제 리플로우 후 스크롤 재계산
                container.offsetHeight;
                
                // 스크롤바 재계산을 위한 일시적 숨김/표시
                const originalOverflow = container.style.overflow;
                container.style.overflow = 'hidden';
                
                requestAnimationFrame(() => {
                    container.style.overflow = 'auto';
                    
                    // 가로 스크롤 제거 확인
                    container.scrollLeft = 0;
                    console.log('가로 스크롤 초기화 완료');
                    
                    // 세로 스크롤 범위 재계산 및 조정
                    requestAnimationFrame(() => {
                        const maxScrollTop = Math.max(0, container.scrollHeight - containerHeight);
                        const currentScrollTop = container.scrollTop;
                        
                        console.log('스크롤 범위 재계산:', {
                            scrollHeight: container.scrollHeight,
                            containerHeight,
                            maxScrollTop,
                            currentScrollTop,
                            willAdjust: currentScrollTop > maxScrollTop
                        });
                        
                        // 현재 스크롤 위치가 범위를 벗어나는 경우 조정
                        if (currentScrollTop > maxScrollTop) {
                            container.scrollTop = maxScrollTop;
                            console.log('✓ 스크롤 위치 조정:', maxScrollTop);
                        }
                        
                        // 최종 DOM 위치 확인
                        setTimeout(() => {
                            const wrapperRect = this.pdfWrapper.getBoundingClientRect();
                            const contentRect = this.pdfContent.getBoundingClientRect();
                            const imageRect = this.pdfImage.getBoundingClientRect();
                            const containerRect = this.pdfContainer.getBoundingClientRect();
                            
                            console.log('최종 DOM 위치 확인:', {
                                container: {
                                    top: containerRect.top,
                                    height: containerRect.height,
                                    scrollTop: container.scrollTop
                                },
                                wrapper: {
                                    top: wrapperRect.top,
                                    height: wrapperRect.height,
                                    relativeTop: wrapperRect.top - containerRect.top
                                },
                                content: {
                                    top: contentRect.top,
                                    height: contentRect.height,
                                    relativeTop: contentRect.top - containerRect.top
                                },
                                image: {
                                    top: imageRect.top,
                                    height: imageRect.height,
                                    relativeTop: imageRect.top - containerRect.top
                                }
                            });
                            
                            // 중앙 정렬 확인
                            if (shouldCenter) {
                                const imageCenter = imageRect.top + imageRect.height / 2;
                                const containerCenter = containerRect.top + containerRect.height / 2;
                                const centerOffset = imageCenter - containerCenter;
                                console.log('중앙 정렬 검증:', {
                                    imageCenter,
                                    containerCenter,
                                    centerOffset,
                                    isCentered: Math.abs(centerOffset) < 10
                                });
                            }
                            
                            console.log('=== forceUpdateScrollAreaForWidthFit 상세 디버깅 완료 ===');
                        }, 50);
                    });
                });
            }

            // 확대된 상태에서 스크롤 영역이 올바른지 확인
            ensureScrollAreaCorrect() {
                const container = this.pdfContainer;
                const wrapper = this.pdfWrapper;
                
                // 현재 PDF 크기
                const pdfWidth = this.originalPageWidth * this.scale;
                const pdfHeight = this.originalPageHeight * this.scale;
                
                // 컨테이너 크기
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // wrapper 크기 재설정 (여백 포함)
                const margin = 20;
                const wrapperWidth = pdfWidth + margin * 2;
                const wrapperHeight = pdfHeight + margin * 2;
                
                wrapper.style.width = Math.max(wrapperWidth, containerWidth) + 'px';
                wrapper.style.height = Math.max(wrapperHeight, containerHeight) + 'px';
                
                // PDF content는 margin 제거
                this.pdfContent.style.margin = '0';
                
                // 강제 리플로우
                container.offsetHeight;
                
                // 스크롤 위치 리셋
                if (container.scrollTop === 0) {
                    // 약간 스크롤했다가 다시 0으로 돌려서 스크롤바 재계산
                    container.scrollTop = 1;
                    requestAnimationFrame(() => {
                        container.scrollTop = 0;
                    });
                }
            }

            bindEvents() {
                // 모바일/데스크톱에 따른 파일 업로드 이벤트 분기
                if (this.isMobile) {
                    // 모바일: 파일 선택
                    this.uploadArea.addEventListener('click', () => this.fileInput.click());
                } else {
                    // 데스크톱: 폴더 선택
                    this.uploadArea.addEventListener('click', () => this.folderInput.click());
                }
                
                this.fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
                
                // 드래그 앤 드롭
                this.uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.add('dragover');
                });
                
                this.uploadArea.addEventListener('dragleave', () => {
                    this.uploadArea.classList.remove('dragover');
                });
                
                this.uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.uploadArea.classList.remove('dragover');
                    const files = Array.from(e.dataTransfer.files);
                    
                    // PDF 파일만 필터링
                    const pdfFiles = files.filter(file => file.type === 'application/pdf');
                    
                    if (pdfFiles.length === 0 && files.length > 0) {
                        this.showToastMessage('📁 PDF 파일이 포함된 폴더를 선택해주세요');
                        return;
                    } else if (pdfFiles.length === 0) {
                        this.showToastMessage('❌ 파일을 인식할 수 없습니다');
                        return;
                    }
                    
                    if (pdfFiles.length === 1 || this.isMobile) {
                        // 단일 PDF 파일이거나 모바일이면 바로 열기
                        this.handleFile(pdfFiles[0]);
                    } else {
                        // 데스크톱에서 여러 PDF 파일이면 폴더 구조로 만들어서 폴더 탐색기에 표시
                        this.buildFolderStructureFromDroppedFiles(pdfFiles);
                        
                        // 폴더 선택 완료 메시지 표시
                        this.showFolderSelectedMessage();
                        
                        // 아이콘 패널이 안 열려있으면 열기
                        if (!this.isIconPanelOpen) {
                            this.toggleIconPanel();
                            // 애니메이션 시간을 기다린 후 폴더 탭 열기
                            setTimeout(() => {
                                this.openFolder();
                                this.renderFolderTree();
                            }, 200);
                        } else {
                            // 이미 열려있으면 바로 폴더 탭 열기
                            this.openFolder();
                            this.renderFolderTree();
                        }
                        
                        this.showToastMessage(`✅ ${pdfFiles.length}개의 PDF 파일을 추가했습니다`);
                    }
                });

                // 새로운 UI 이벤트들
                // 사이드바 토글 이벤트 (이미 있는 코드 확인)
                this.sidebarToggle.addEventListener('click', () => {
                    console.log('햄버거 버튼 클릭됨'); // 디버깅용
                    this.toggleIconPanel();
                });
                this.thumbnailsBtn.addEventListener('click', () => {
                    this.toggleThumbnails();
                });
                
                // 모바일/데스크톱에 따른 폴더 버튼 이벤트 분기
                if (this.isMobile) {
                    // 모바일: 새 파일 선택
                    this.folderBtn.title = '파일 선택';
                    this.folderBtn.addEventListener('click', () => {
                        this.fileInput.click();
                        // 사이드바 닫기
                        if (this.isIconPanelOpen) {
                            this.toggleIconPanel();
                        }
                    });
                    this.selectFolderBtn.addEventListener('click', (e) => {
                        this.fileInput.click();
                        if (this.isIconPanelOpen) {
                            this.toggleIconPanel();
                        }
                    });
                } else {
                    // 데스크톱: 폴더 탐색기 토글
                    this.folderBtn.title = '폴더 탐색기';
                    this.folderBtn.addEventListener('click', () => {
                        this.toggleFolder();
                    });
                    this.selectFolderBtn.addEventListener('click', (e) => {
                        this.openFolderDialog(e);
                    });
                }
                
                this.folderInput.addEventListener('change', (e) => {
                    this.handleFolderSelect(e);
                });
                
                // 테마 토글 이벤트
                this.themeToggleBtn.addEventListener('click', () => {
                    this.toggleTheme();
                });
                
                // 시스템 테마 변경 감지
                if (window.matchMedia) {
                    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                    mediaQuery.addEventListener('change', () => {
                        if (this.currentTheme === 'system') {
                            this.applySystemTheme();
                        }
                    });
                }
                
                // 드롭다운 메뉴 이벤트들
                this.propertiesBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleDropdown();
                });
                
                // 드롭다운 메뉴 항목 이벤트들
                this.dualPageItem.addEventListener('click', () => {
                    // 두 페이지 보기는 비활성화됨
                    this.showToastMessage('📖 두 페이지씩 보기는 현재 개발 중입니다');
                });
                
                this.autoTrackItem.addEventListener('click', () => {
                    this.toggleAutoTrack();
                });
                
                this.toastToggleItem.addEventListener('click', () => {
                    this.toggleToastMessages();
                });
                
                this.presentationItem.addEventListener('click', () => {
                    // 발표 모드는 아직 구현하지 않음
                    this.showToastMessage('🎞️ 발표 모드는 현재 개발 중입니다');
                });
                
                this.documentPropertiesItem.addEventListener('click', () => {
                    this.hideDropdown();
                    this.showDocumentProperties();
                });
                
                this.propertiesCloseBtnFooter.addEventListener('click', () => {
                    this.hideDocumentProperties();
                });
                
                // 드롭다운 외부 클릭시 닫기
                document.addEventListener('click', (e) => {
                    if (this.isDropdownOpen && 
                        !e.target.closest('.dropdown-container') && 
                        !e.target.closest('.dropdown-menu')) {
                        this.hideDropdown();
                    }
                });
                
                this.propertiesModal.addEventListener('click', (e) => {
                    if (e.target === this.propertiesModal) {
                        this.hideDocumentProperties();
                    }
                });
                
                // 기존 드롭다운 이벤트들 뒤에 추가
                this.helpItem.addEventListener('click', () => {
                    this.hideDropdown();
                    this.showHelpModal();
                });

                this.helpCloseBtn.addEventListener('click', () => {
                    this.hideHelpModal();
                });

                this.helpCloseBtnFooter.addEventListener('click', () => {
                    this.hideHelpModal();
                });

                this.helpModal.addEventListener('click', (e) => {
                    if (e.target === this.helpModal) {
                        this.hideHelpModal();
                    }
                });

                // 스마트 복사 버튼 이벤트 추가
                this.copyBtn.addEventListener('click', () => {
                    this.smartCopy();
                });
                
                // 썸네일 창 관련 이벤트들
                this.thumbnailWindowClose.addEventListener('click', () => {
                    this.closeThumbnailWindow();
                });
                
                this.thumbnailWindowModal.addEventListener('click', (e) => {
                    if (e.target === this.thumbnailWindowModal) {
                        this.closeThumbnailWindow();
                    }
                });

                // 썸네일 창 관련 이벤트들 (기존 이벤트들 뒤에 추가)
                this.thumbnailSelectToggle = document.getElementById('thumbnailSelectToggle');
                this.thumbnailSelectToggle.addEventListener('click', () => {
                    this.toggleSelectionMode();
                });
                
                // 초기 빈 영역 클릭 이벤트
                const initialEmptyArea = document.getElementById('folderEmptyArea');
                if (initialEmptyArea) {
                    initialEmptyArea.addEventListener('click', (e) => {
                        if (this.isMobile) {
                            this.fileInput.click();
                            if (this.isIconPanelOpen) {
                                this.toggleIconPanel();
                            }
                        } else {
                            this.openFolderDialog(e);
                        }
                    });
                    
                    // 초기 빈 영역 드래그 앤 드롭 이벤트
                    initialEmptyArea.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        initialEmptyArea.classList.add('dragover');
                    });
                    
                    initialEmptyArea.addEventListener('dragleave', () => {
                        initialEmptyArea.classList.remove('dragover');
                    });
                    
                    initialEmptyArea.addEventListener('drop', (e) => {
                        e.preventDefault();
                        initialEmptyArea.classList.remove('dragover');
                        
                        const files = Array.from(e.dataTransfer.files);
                        const pdfFiles = files.filter(file => file.type === 'application/pdf');
                        
                        if (pdfFiles.length > 0) {
                            if (this.isMobile && pdfFiles.length === 1) {
                                // 모바일에서 단일 파일은 바로 열기
                                this.handleFile(pdfFiles[0]);
                            } else if (!this.isMobile) {
                                // 데스크톱에서만 폴더 구조 생성
                                this.buildFolderStructureFromDroppedFiles(pdfFiles);
                                this.renderFolderTree();
                                this.showToastMessage(`✅ ${pdfFiles.length}개의 PDF 파일을 추가했습니다`);
                            }
                        } else {
                            this.showToastMessage('❌ PDF 파일만 드롭할 수 있습니다');
                        }
                    });
                }

                // 줌 컨트롤
                this.zoomIn.addEventListener('click', () => {
                    if (!this.zoomIn.classList.contains('disabled')) {
                        this.zoomPage(1.25);
                    }
                });
                this.zoomOut.addEventListener('click', () => {
                    if (!this.zoomOut.classList.contains('disabled')) {
                        this.zoomPage(0.8);
                    }
                });
                this.zoomSelect.addEventListener('change', () => this.setZoomFromSelect());

                // 맞춤 토글 버튼
                this.fitToggleBtn.addEventListener('click', () => this.toggleFit());

                // 캡쳐 버튼
                this.captureBtn.addEventListener('click', () => this.toggleCaptureMode());

                // 페이지 입력
                this.pageInput.addEventListener('change', () => this.goToPage());
                this.pageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.goToPage();
                });

                // 키보드 이벤트
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));

                // 마우스 휠 이벤트
                this.pdfContainer.addEventListener('wheel', (e) => this.handleWheel(e));
                
                // PDF 컨테이너 스크롤 시 드롭다운 닫기
                this.pdfContainer.addEventListener('scroll', () => {
                    if (this.isDropdownOpen) {
                        this.hideDropdown();
                    }
                });

                // 윈도우 리사이즈
                window.addEventListener('resize', () => {
                    // 모바일 감지 업데이트
                    const wasMobile = this.isMobile;
                    this.isMobile = this.detectMobile();
                    
                    // 모바일 상태가 변경되었으면 UI 재설정
                    if (wasMobile !== this.isMobile) {
                        this.setupMobileUI();
                        // 기본 사이드바 타입도 업데이트
                        this.lastOpenedSidebarType = this.isMobile ? 'thumbnails' : 'folder';
                        // 폴더 버튼 title 업데이트
                        this.folderBtn.title = this.isMobile ? '파일 선택' : '폴더 탐색기';
                    }
                    
                    this.handleResize();
                });
                
                // 캡쳐 오버레이 이벤트 (마우스 + 터치)
                this.captureOverlay.addEventListener('mousedown', (e) => this.startSelection(e));
                this.captureOverlay.addEventListener('mousemove', (e) => this.updateSelection(e));
                this.captureOverlay.addEventListener('mouseup', (e) => this.endSelection(e));
                this.captureOverlay.addEventListener('mouseleave', (e) => this.cancelSelection(e));
                
                // 터치 이벤트 추가
                this.captureOverlay.addEventListener('touchstart', (e) => this.startSelection(e));
                this.captureOverlay.addEventListener('touchmove', (e) => this.updateSelection(e));
                this.captureOverlay.addEventListener('touchend', (e) => this.endSelection(e));
                
                // PDF 컨테이너 터치/스와이프 이벤트
                this.pdfContainer.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.pdfContainer.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }
            
            // 커스텀 확인 모달 표시
            showConfirmModal(title, message) {
                return new Promise((resolve) => {
                    const modal = document.getElementById('confirmModal');
                    const titleEl = document.getElementById('confirmTitle');
                    const messageEl = document.getElementById('confirmMessage');
                    const cancelBtn = document.getElementById('confirmCancel');
                    const okBtn = document.getElementById('confirmOk');
                    
                    titleEl.textContent = title;
                    messageEl.textContent = message;
                    
                    // 모달 표시
                    modal.style.display = 'flex';
                    setTimeout(() => modal.classList.add('show'), 10);
                    
                    // 이벤트 핸들러 (한 번만 실행)
                    const handleCancel = () => {
                        this.hideConfirmModal();
                        cleanup();
                        resolve(false);
                    };
                    
                    const handleOk = () => {
                        this.hideConfirmModal();
                        cleanup();
                        resolve(true);
                    };
                    
                    const cleanup = () => {
                        cancelBtn.removeEventListener('click', handleCancel);
                        okBtn.removeEventListener('click', handleOk);
                    };
                    
                    cancelBtn.addEventListener('click', handleCancel);
                    okBtn.addEventListener('click', handleOk);
                    
                    // ESC 키로 닫기
                    const handleKeydown = (e) => {
                        if (e.key === 'Escape') {
                            handleCancel();
                            document.removeEventListener('keydown', handleKeydown);
                        }
                    };
                    document.addEventListener('keydown', handleKeydown);
                });
            }

            // 커스텀 확인 모달 숨기기
            hideConfirmModal() {
                const modal = document.getElementById('confirmModal');
                modal.classList.remove('show');
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }

            // 토스트 메시지 위치 업데이트
            updateToastPosition(hasToolbar) {
                if (hasToolbar) {
                    this.toastContainer.classList.add('with-toolbar');
                } else {
                    this.toastContainer.classList.remove('with-toolbar');
                }
                
                // 드롭다운 상태도 함께 고려
                if (this.isDropdownOpen) {
                    this.toastContainer.classList.add('dropdown-open');
                } else {
                    this.toastContainer.classList.remove('dropdown-open');
                }
            }

            // 초기 테마 설정
            initializeTheme() {
                // 기본적으로 시스템 설정으로 시작
                this.currentTheme = 'system';
                this.themeToggleBtn.textContent = '⚙️';
                this.themeToggleBtn.title = '시스템 설정';
                this.applySystemTheme();
            }

            // 테마 토글 기능
            toggleTheme() {
                switch (this.currentTheme) {
                    case 'dark':
                        this.currentTheme = 'light';
                        this.themeToggleBtn.textContent = '☀️';
                        this.themeToggleBtn.title = '라이트모드';
                        document.body.classList.add('light-theme');
                        break;
                    case 'light':
                        this.currentTheme = 'system';
                        this.themeToggleBtn.textContent = '⚙️';
                        this.themeToggleBtn.title = '시스템 설정';
                        this.applySystemTheme();
                        break;
                    case 'system':
                        this.currentTheme = 'dark';
                        this.themeToggleBtn.textContent = '🌙';
                        this.themeToggleBtn.title = '다크모드';
                        document.body.classList.remove('light-theme');
                        break;
                }
                
                // 테마 변경 시 사용법 가이드 텍스트 색상 업데이트
                this.setupMobileUI();
            }

            // 시스템 테마 적용
            applySystemTheme() {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    // 시스템이 다크모드
                    document.body.classList.remove('light-theme');
                } else {
                    // 시스템이 라이트모드
                    document.body.classList.add('light-theme');
                }
                
                // 시스템 테마 변경 시에도 사용법 가이드 텍스트 색상 업데이트
                this.setupMobileUI();
            }

            // 문서 속성 표시
            async showDocumentProperties() {
                if (!this.pdf || !this.currentFile) {
                    this.showAlertModal('문서 속성', 'PDF 파일이 로드되지 않았습니다.');
                    return;
                }

                try {
                    // PDF 메타데이터 가져오기
                    const metadata = await this.pdf.getMetadata();
                    const info = metadata.info;
                    
                    // 첫 번째 페이지에서 크기 정보 가져오기
                    const firstPage = await this.pdf.getPage(1);
                    const viewport = firstPage.getViewport({scale: 1.0});
                    
                    // 파일 크기 포맷팅
                    const fileSize = this.formatFileSize(this.currentFile.size);
                    
                    // 페이지 크기 계산 (72 DPI 기준으로 mm 변환)
                    const widthMm = Math.round(viewport.width * 25.4 / 72);
                    const heightMm = Math.round(viewport.height * 25.4 / 72);
                    const orientation = viewport.width > viewport.height ? '가로 모드' : '세로 모드';
                    
                    // 날짜 포맷팅 개선
                    const formatDate = (dateStr) => {
                        if (!dateStr) return '-';
                        
                        try {
                            let date;
                            
                            // PDF 표준 날짜 형식 처리 (D:YYYYMMDDHHmmSSOHH'mm')
                            if (typeof dateStr === 'string' && dateStr.startsWith('D:')) {
                                const cleanDate = dateStr.substring(2); // D: 제거
                                const year = cleanDate.substring(0, 4);
                                const month = cleanDate.substring(4, 6);
                                const day = cleanDate.substring(6, 8);
                                const hour = cleanDate.substring(8, 10) || '00';
                                const minute = cleanDate.substring(10, 12) || '00';
                                const second = cleanDate.substring(12, 14) || '00';
                                
                                // ISO 형식으로 변환
                                const isoString = `${year}-${month}-${day}T${hour}:${minute}:${second}`;
                                date = new Date(isoString);
                            } else {
                                // 일반 날짜 문자열 처리
                                date = new Date(dateStr);
                            }
                            
                            if (isNaN(date.getTime())) return '-';
                            
                            return date.toLocaleString('ko-KR', {
                                year: '2-digit',
                                month: 'numeric',
                                day: 'numeric',
                                weekday: 'short',
                                hour: 'numeric',
                                minute: 'numeric',
                                second: 'numeric',
                                hour12: false
                            }).replace(/\./g, '. ');
                        } catch (e) {
                            console.log('날짜 파싱 오류:', e, '원본:', dateStr);
                            return '-';
                        }
                    };

                    // 속성 데이터 구성
                    const properties = [
                        {
                            group: '기본 정보',
                            items: [
                                { label: '파일 이름:', value: this.currentFile.name },
                                { label: '파일 크기:', value: fileSize }
                            ]
                        },
                        {
                            group: '',
                            items: [
                                { label: '직책:', value: info.Title || this.currentFile.name.replace('.pdf', '') },
                                { label: '작성자:', value: info.Author || '-' },
                                { label: '제목:', value: info.Subject || '-' },
                                { label: '키워드:', value: info.Keywords || '-' },
                                { label: '생성됨:', value: formatDate(info.CreationDate) },
                                { label: '수정:', value: formatDate(info.ModDate) },
                                { label: '애플리케이션:', value: info.Creator || '-' }
                            ]
                        },
                        {
                            group: '',
                            items: [
                                { label: 'PDF 변환 프로그램:', value: info.Producer || '-' },
                                { label: 'PDF 버전:', value: metadata.metadata?.get('pdf:PDFVersion') || '1.7' },
                                { label: '페이지 수:', value: this.totalPages.toString() },
                                { label: '페이지 크기:', value: `${widthMm}×${heightMm}mm(${orientation})` }
                            ]
                        },
                        {
                            group: '',
                            items: [
                                { label: '빠른 웹 보기:', value: '아니요' }
                            ]
                        }
                    ];

                    // HTML 생성
                    this.propertiesContent.innerHTML = '';
                    
                    properties.forEach(group => {
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'property-group';
                        
                        group.items.forEach(item => {
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'property-item';
                            
                            const labelDiv = document.createElement('div');
                            labelDiv.className = 'property-label';
                            labelDiv.textContent = item.label;
                            
                            const valueDiv = document.createElement('div');
                            valueDiv.className = 'property-value';
                            valueDiv.textContent = item.value;
                            
                            itemDiv.appendChild(labelDiv);
                            itemDiv.appendChild(valueDiv);
                            groupDiv.appendChild(itemDiv);
                        });
                        
                        this.propertiesContent.appendChild(groupDiv);
                    });

                    // 모달 표시 (애니메이션과 함께)
                    this.propertiesModal.style.display = 'flex';
                    // 브라우저가 렌더링을 완료한 후 show 클래스 추가
                    setTimeout(() => {
                        this.propertiesModal.classList.add('show');
                    }, 10);
                    
                } catch (error) {
                    console.error('문서 속성 로드 실패:', error);
                    this.showAlertModal('오류', '문서 속성을 가져오는데 실패했습니다.');
                }
            }

            // 문서 속성 숨기기 (애니메이션과 함께)
            hideDocumentProperties() {
                this.propertiesModal.classList.remove('show');
                // 애니메이션 완료 후 display none
                setTimeout(() => {
                    if (!this.propertiesModal.classList.contains('show')) {
                        this.propertiesModal.style.display = 'none';
                    }
                }, 300);
            }

            // 파일 크기 포맷팅
            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + sizes[i];
            }

            // 폴더 선택 다이얼로그 열기 메서드 추가
            openFolderDialog() {
                console.log('폴더 선택 다이얼로그 열기');
                this.folderInput.click();
            }

            // 썸네일 창 열기
            openThumbnailWindow() {
                if (!this.pdf || this.thumbnails.length === 0) {
                    this.showToastMessage('📄 PDF가 로드되지 않았거나 썸네일이 생성되지 않았습니다');
                    return;
                }

                this.isThumbnailWindowOpen = true;
                this.thumbnailMode = 'window';
                
                // 기존 그리드 내용 지우기
                this.thumbnailWindowGrid.innerHTML = '';
                
                // 모든 썸네일을 창에 복사 - 캔버스 내용을 실제로 복사
                this.thumbnails.forEach((thumbnail, index) => {
                    if (thumbnail) {
                        // 새로운 썸네일 아이템 생성
                        const newThumbnailItem = document.createElement('div');
                        newThumbnailItem.className = 'thumbnail-item';
                        newThumbnailItem.dataset.page = index + 1;
                        
                        // 원본 캔버스 찾기
                        const originalCanvas = thumbnail.querySelector('.thumbnail-canvas');
                        if (originalCanvas) {
                            // 새로운 캔버스 생성 및 내용 복사
                            const newCanvas = document.createElement('canvas');
                            newCanvas.className = 'thumbnail-canvas';
                            newCanvas.width = originalCanvas.width;
                            newCanvas.height = originalCanvas.height;
                            
                            const newCtx = newCanvas.getContext('2d');
                            newCtx.drawImage(originalCanvas, 0, 0);
                            
                            newThumbnailItem.appendChild(newCanvas);
                        }
                        
                        // 라벨 복사
                        const originalLabel = thumbnail.querySelector('.thumbnail-label');
                        if (originalLabel) {
                            const newLabel = document.createElement('div');
                            newLabel.className = 'thumbnail-label';
                            newLabel.textContent = originalLabel.textContent;
                            newThumbnailItem.appendChild(newLabel);
                        }
                        
                        // 클릭 이벤트 추가 (기존 코드에서 이 부분만 교체)
                        newThumbnailItem.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            if (this.isSelectionMode) {
                                // 선택 모드: Shift 키 감지
                                if (e.shiftKey && this.lastSelectedPage !== null) {
                                    // Shift + 클릭: 범위 선택
                                    this.selectRange(this.lastSelectedPage, index + 1);
                                } else {
                                    // 일반 클릭 또는 Ctrl + 클릭: 개별 토글 (기존 선택 유지)
                                    this.togglePageSelection(index + 1, newThumbnailItem, false); // clearOthers를 false로 변경
                                }
                            } else {
                                // 일반 모드: 페이지 이동
                                this.goToPageFromThumbnailWindow(index + 1);
                            }
                        });
                        
                        this.thumbnailWindowGrid.appendChild(newThumbnailItem);
                    }
                });
                
                // 모달 표시 (애니메이션과 함께)
                this.thumbnailWindowModal.style.display = 'flex';
                setTimeout(() => {
                    this.thumbnailWindowModal.classList.add('show');
                }, 10);
                
                // 현재 페이지 선택 상태 업데이트
                this.updateThumbnailWindowSelection();
                
                // 버튼 상태 업데이트
                this.updateThumbnailButtonState();
                
                this.showToastMessage('🪟 축소판 창이 열렸습니다!');
            }
            
            // 썸네일 창 닫기 (끝부분에 추가)
            closeThumbnailWindow(customMessage = null) {
                this.isThumbnailWindowOpen = false;
                this.thumbnailMode = this.isThumbnailsOpen ? 'sidebar' : 'none';
                
                this.thumbnailWindowModal.classList.remove('show');
                setTimeout(() => {
                    if (!this.isThumbnailWindowOpen) {
                        this.thumbnailWindowModal.style.display = 'none';
                    }
                }, 300);
                
                // 버튼 상태 업데이트
                this.updateThumbnailButtonState();
                
                // 선택 모드 초기화 (추가)
                if (this.isSelectionMode) {
                    this.isSelectionMode = false;
                    this.selectedPages.clear();
                    this.thumbnailSelectToggle.classList.remove('active');
                    this.thumbnailSelectToggle.title = '다중 선택 모드';
                }
                
                // 커스텀 메시지가 있으면 그걸 사용, 없으면 기본 메시지
                const message = customMessage || '📄 축소판 창이 닫혔습니다';
                this.showToastMessage(message);
            }

            async goToPageFromThumbnailWindow(pageNum) {
                if (pageNum < 1 || pageNum > this.totalPages || pageNum === this.currentPage) {
                    return;
                }
                
                console.log('=== THUMBNAIL WINDOW PAGE 시작 ===');
                console.log('현재 페이지:', this.currentPage, '→', pageNum);
                
                // 페이지 이동 중 플래그 설정
                this.isPageTransitioning = true;
                
                try {
                    this.currentPage = pageNum;

                    // 1. 렌더링 전에 새 페이지에 맞는 스케일 계산
                    if (this.fitMode !== 'none') {
                        const page = await this.pdf.getPage(this.currentPage);
                        if (this.fitMode === 'width') {
                            await this.calculateFitToWidth(page);
                        } else if (this.fitMode === 'page') {
                            await this.calculateFitToPage(page);
                        }
                    }
                    
                    // 2. 페이지 렌더링 완료까지 대기
                    await this.renderPage();
                    
                    // 3. UI 업데이트
                    this.updateUI();
                    this.updateThumbnailSelection();
                    this.updateThumbnailWindowSelection();

                    // 4. 스크롤 위치를 확실하게 고정
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.forceScrollToTopForPageTransition();

                    // 5. 자동 복사 기능 실행
                    await this.performAutoTrack();
                    
                    // 6. 썸네일 창 닫기
                    this.isThumbnailWindowOpen = false;
                    this.thumbnailMode = this.isThumbnailsOpen ? 'sidebar' : 'none';
                    
                    this.thumbnailWindowModal.classList.remove('show');
                    setTimeout(() => {
                        if (!this.isThumbnailWindowOpen) {
                            this.thumbnailWindowModal.style.display = 'none';
                        }
                    }, 300);
                    
                    this.updateThumbnailButtonState();
                    this.showToastMessage(`📖 ${pageNum}페이지로 이동했습니다`);
                    
                } catch (error) {
                    console.error('썸네일 창에서 페이지 이동 실패:', error);
                    this.showToastMessage('❌ 페이지 이동에 실패했습니다');
                } finally {
                    // 페이지 이동 완료 후 플래그 해제
                    setTimeout(() => {
                        this.isPageTransitioning = false;
                        console.log('페이지 이동 완료, maintainPDFCenter 재활성화');
                    }, 300);
                }
            }

            async stabilizeLayoutAndScroll(scrollDirection = 'top') {
                const container = this.pdfContainer;
                
                // 레이아웃 안정화 대기
                await new Promise(resolve => {
                    if (this.fitMode === 'width') {
                        // 너비 맞춤 모드는 더 긴 안정화 시간 필요
                        setTimeout(resolve, 150);
                    } else {
                        setTimeout(resolve, 50);
                    }
                });
                
                // 스크롤 영역 재계산
                if (this.fitMode === 'width') {
                    this.forceUpdateScrollAreaForWidthFit();
                    
                    // 추가 안정화 대기
                    await new Promise(resolve => setTimeout(resolve, 100));
                } else {
                    // 강제 리플로우
                    container.offsetHeight;
                }
                
                // 스크롤 위치 조정
                return new Promise(resolve => {
                    requestAnimationFrame(() => {
                        try {
                            if (scrollDirection === 'top') {
                                this.scrollToTopOptimized();
                            } else if (scrollDirection === 'bottom') {
                                this.scrollToBottomOptimized();
                            }
                            
                            // 최종 검증
                            setTimeout(() => {
                                this.validateScrollArea();
                                resolve();
                            }, 50);
                            
                        } catch (error) {
                            console.error('스크롤 조정 실패:', error);
                            resolve();
                        }
                    });
                });
            }

            // 썸네일 창의 선택 상태 업데이트
            updateThumbnailWindowSelection() {
                if (!this.isThumbnailWindowOpen) return;
                
                // 모든 썸네일에서 active 클래스 제거
                const windowThumbnails = this.thumbnailWindowGrid.querySelectorAll('.thumbnail-item');
                windowThumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('active');
                });
                
                // 현재 페이지에 해당하는 썸네일에 active 클래스 추가
                if (windowThumbnails[this.currentPage - 1]) {
                    const currentThumbnail = windowThumbnails[this.currentPage - 1];
                    currentThumbnail.classList.add('active');
                    
                    // 현재 페이지의 오버레이 스타일 업데이트
                    const overlay = currentThumbnail.querySelector('.selection-overlay');
                    if (overlay && this.isSelectionMode) {
                        if (this.selectedPages.has(this.currentPage)) {
                            // 현재 페이지가 선택되어 있으면 그라데이션
                            overlay.style.background = 'linear-gradient(45deg, rgba(255, 152, 0, 0.2), rgba(66, 133, 244, 0.2))';
                            overlay.style.borderColor = '#ff9800';
                        } else {
                            // 현재 페이지가 선택되지 않았으면 주황색 테두리만
                            overlay.style.backgroundColor = 'transparent';
                            overlay.style.borderColor = '#ff9800';
                        }
                    }
                    
                    // 현재 썸네일이 보이도록 스크롤
                    currentThumbnail.scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            }

            // 선택 모드 토글
            toggleSelectionMode() {
                this.isSelectionMode = !this.isSelectionMode;
                
                if (this.isSelectionMode) {
                    this.thumbnailSelectToggle.classList.add('active');
                    this.thumbnailSelectToggle.title = '선택 모드 (활성)';
                    this.showThumbnailCheckboxes(); // 함수명은 그대로 두되 내용은 색상 표시로 변경됨
                    this.showToastMessage('☑️ 선택 모드 활성화 - 축소판을 클릭하여 선택하세요');
                } else {
                    this.thumbnailSelectToggle.classList.remove('active');
                    this.thumbnailSelectToggle.title = '다중 선택 모드';
                    this.hideThumbnailCheckboxes(); // 함수명은 그대로 두되 내용은 색상 제거로 변경됨
                    this.selectedPages.clear();
                    this.showToastMessage('📄 선택 모드 비활성화');
                }
            }

            // 선택 모드 활성화 (기존 코드 끝에 추가)
            showThumbnailCheckboxes() {
                const windowThumbnails = this.thumbnailWindowGrid.querySelectorAll('.thumbnail-item');
                windowThumbnails.forEach((thumbnail, index) => {
                    // 축소판에 선택 모드 클래스 추가
                    thumbnail.classList.add('selection-mode');
                    
                    // 선택 오버레이 생성
                    const existingOverlay = thumbnail.querySelector('.selection-overlay');
                    if (existingOverlay) {
                        existingOverlay.remove();
                    }
                    
                    const overlay = document.createElement('div');
                    overlay.className = 'selection-overlay';
                    overlay.style.position = 'absolute';
                    overlay.style.top = '0';
                    overlay.style.left = '0';
                    overlay.style.right = '0';
                    overlay.style.bottom = '0';
                    overlay.style.backgroundColor = 'transparent';
                    overlay.style.border = '3px solid transparent';
                    overlay.style.borderRadius = '8px';
                    overlay.style.transition = 'all 0.3s ease';
                    overlay.style.pointerEvents = 'none';
                    overlay.style.zIndex = '5';
                    
                    thumbnail.style.position = 'relative';
                    thumbnail.appendChild(overlay);
                });
                
                // 현재 페이지 스타일 재적용 (추가)
                this.updateThumbnailWindowSelection();
            }

            // 선택 모드 비활성화
            hideThumbnailCheckboxes() {
                // 선택 오버레이 제거
                const overlays = this.thumbnailWindowGrid.querySelectorAll('.selection-overlay');
                overlays.forEach(overlay => overlay.remove());
                
                // 선택 표시와 선택 모드 클래스 제거
                const windowThumbnails = this.thumbnailWindowGrid.querySelectorAll('.thumbnail-item');
                windowThumbnails.forEach(thumbnail => {
                    thumbnail.classList.remove('selected', 'selection-mode');
                });
                
                // 마지막 선택 페이지 초기화 (추가)
                this.lastSelectedPage = null;
            }

            // 페이지 선택 토글 (개선된 버전)
            togglePageSelection(pageNum, thumbnailElement, clearOthers = false) {
                // clearOthers가 true면 다른 선택들 모두 해제 (일반 클릭)
                if (clearOthers && !this.selectedPages.has(pageNum)) {
                    // 기존 선택 모두 해제
                    this.selectedPages.forEach(selectedPage => {
                        const selectedElement = this.thumbnailWindowGrid.querySelector(`[data-page="${selectedPage}"]`);
                        if (selectedElement) {
                            this.applySelectionStyle(selectedElement, false);
                        }
                    });
                    this.selectedPages.clear();
                }
                
                if (this.selectedPages.has(pageNum)) {
                    // 선택 해제
                    this.selectedPages.delete(pageNum);
                    this.applySelectionStyle(thumbnailElement, false);
                    
                    // 마지막 선택된 페이지가 해제되면 null로 설정
                    if (this.lastSelectedPage === pageNum) {
                        this.lastSelectedPage = this.selectedPages.size > 0 ? 
                            Math.max(...this.selectedPages) : null;
                    }
                } else {
                    // 선택
                    this.selectedPages.add(pageNum);
                    this.applySelectionStyle(thumbnailElement, true);
                    this.lastSelectedPage = pageNum;
                }
                
                // 선택된 페이지 수 표시
                const count = this.selectedPages.size;
                if (count > 0) {
                    this.showToastMessage(`📋 ${count}개 페이지 선택됨`);
                } else {
                    this.showToastMessage('📄 선택된 페이지 없음');
                }
            }
            
            // 범위 선택 함수
            selectRange(startPage, endPage) {
                // 시작과 끝 페이지 정렬
                const start = Math.min(startPage, endPage);
                const end = Math.max(startPage, endPage);
                
                // 범위 내의 모든 페이지 선택
                for (let pageNum = start; pageNum <= end; pageNum++) {
                    if (!this.selectedPages.has(pageNum)) {
                        this.selectedPages.add(pageNum);
                        
                        // 해당 축소판 요소 찾아서 선택 표시
                        const thumbnailElement = this.thumbnailWindowGrid.querySelector(`[data-page="${pageNum}"]`);
                        if (thumbnailElement) {
                            this.applySelectionStyle(thumbnailElement, true);
                        }
                    }
                }
                
                // 마지막 선택된 페이지 업데이트
                this.lastSelectedPage = endPage;
                
                // 선택된 페이지 수 표시
                const count = this.selectedPages.size;
                this.showToastMessage(`📋 ${start}-${end}페이지 범위 선택 (총 ${count}개 선택됨)`);
            }

            // 모든 선택 해제
            clearSelection() {
                if (!this.isSelectionMode) return;
                
                this.selectedPages.forEach(pageNum => {
                    const thumbnailElement = this.thumbnailWindowGrid.querySelector(`[data-page="${pageNum}"]`);
                    if (thumbnailElement) {
                        this.applySelectionStyle(thumbnailElement, false);
                    }
                });
                
                this.selectedPages.clear();
                this.lastSelectedPage = null;
                this.showToastMessage('📄 모든 선택 해제됨');
            }
            
            // 모든 축소판 선택
            selectAllThumbnails() {
                if (!this.isSelectionMode) return;
                
                const windowThumbnails = this.thumbnailWindowGrid.querySelectorAll('.thumbnail-item');
                windowThumbnails.forEach((thumbnail, index) => {
                    const pageNum = index + 1;
                    this.selectedPages.add(pageNum);
                    this.applySelectionStyle(thumbnail, true);
                });
                
                this.lastSelectedPage = this.totalPages;
                this.showToastMessage(`📋 모든 페이지 선택됨 (${this.selectedPages.size}개)`);
            }

            // 선택 스타일 적용/제거 (현재 페이지 고려)
            applySelectionStyle(thumbnailElement, isSelected) {
                const overlay = thumbnailElement.querySelector('.selection-overlay');
                const isCurrentPage = thumbnailElement.classList.contains('active');
                
                if (isSelected) {
                    thumbnailElement.classList.add('selected');
                    if (overlay) {
                        if (isCurrentPage) {
                            // 현재 페이지가 선택된 경우: 그라데이션 배경
                            overlay.style.background = 'linear-gradient(45deg, rgba(255, 152, 0, 0.2), rgba(66, 133, 244, 0.2))';
                            overlay.style.borderColor = '#ff9800'; // 주황색 테두리 유지
                        } else {
                            // 일반 선택: 파란색
                            overlay.style.backgroundColor = 'rgba(66, 133, 244, 0.3)';
                            overlay.style.borderColor = '#4285f4';
                        }
                    }
                } else {
                    thumbnailElement.classList.remove('selected');
                    if (overlay) {
                        if (isCurrentPage) {
                            // 현재 페이지는 선택 해제되어도 주황색 테두리 유지
                            overlay.style.backgroundColor = 'transparent';
                            overlay.style.borderColor = '#ff9800';
                        } else {
                            // 일반 페이지는 완전히 투명
                            overlay.style.backgroundColor = 'transparent';
                            overlay.style.borderColor = 'transparent';
                        }
                    }
                }
            }

            async handleFile(file) {
                if (!file || file.type !== 'application/pdf') {
                    await this.showAlertModal('파일 오류', 'PDF 파일만 업로드 가능합니다.');
                    return;
                }

                this.loading.style.display = 'block';
                this.currentFile = file; // 현재 파일 저장
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                    this.totalPages = this.pdf.numPages;
                    this.currentPage = 1;
                    
                    // 파일 제목 업데이트
                    this.fileTitle.textContent = file.name;
                    
                    // 브라우저 탭 제목도 파일명으로 업데이트
                    document.title = file.name;
                    
                    this.showPDFViewer();
                    
                    // 먼저 기본 스케일로 렌더링 (원본 크기 정보 획득)
                    await this.renderPage();
                    
                    // 썸네일 생성 시작
                    this.generateThumbnails();
                    
                    // 원본 크기 정보를 얻은 후에 페이지 맞춤 적용
                    if (this.originalPageWidth && this.originalPageHeight) {
                        this.fitMode = 'page';
                        const page = await this.pdf.getPage(this.currentPage);
                        await this.calculateFitToPage(page);
                        
                        // 페이지 맞춤 스케일로 다시 렌더링
                        await this.renderPage();
                    }
                    
                    this.updateUI();
                    this.updateFitToggle();
                    
                    // PDF 로드 완료 시 썸네일 버튼 활성화
                    this.thumbnailsBtn.disabled = false;
                    
                } catch (error) {
                    await this.showAlertModal('PDF 로드 실패', 'PDF 파일을 로드하는데 실패했습니다.\n\n오류: ' + error.message);
                    console.error(error);
                } finally {
                    this.loading.style.display = 'none';
                }
            }

            showFolderSelectedMessage() {
                this.uploadArea.style.display = 'none';
                this.folderSelectedMessage.style.display = 'flex';
                this.toolbar.style.display = 'none';
                this.pdfViewer.style.display = 'none';
                
                // 제목을 기본값으로 되돌리기
                document.title = 'PDF Viewer';
                
                // 토스트 위치 업데이트 (툴바가 없으므로)
                this.updateToastPosition(false);
            }

            showPDFViewer() {
                this.uploadArea.style.display = 'none';
                this.folderSelectedMessage.style.display = 'none';
                this.toolbar.style.display = 'flex';
                this.pdfViewer.style.display = 'flex';
                
                // PDF 뷰어가 열릴 때 썸네일 버튼 활성화 확인
                if (this.pdf) {
                    this.thumbnailsBtn.disabled = false;
                }
                
                // 토스트 위치 업데이트 (툴바가 있으므로)
                this.updateToastPosition(true);
            }

            // 햄버거 버튼 - 아이콘 패널 토글
            toggleIconPanel() {
                // 캡쳐 모드가 활성화되어 있으면 종료
                if (this.isCaptureMode) {
                    this.exitCaptureMode();
                }
                
                // 드롭다운이 열려있으면 닫기
                if (this.isDropdownOpen) {
                    this.hideDropdown();
                }
                
                // 썸네일 창이 열려있으면 닫기
                if (this.isThumbnailWindowOpen) {
                    this.closeThumbnailWindow();
                }
                
                // 사이드바 토글 전 현재 중심점 저장
                let centerRatio = 0;
                if (!this.isMobile && this.pdf) {
                    const container = this.pdfContainer;
                    const currentCenterX = container.scrollLeft + (container.clientWidth / 2);
                    const totalWidth = container.scrollWidth;
                    centerRatio = totalWidth > 0 ? currentCenterX / totalWidth : 0.5;
                }
                
                console.log('=== 사이드바 토글 전 ===');
                console.log('main-layout 너비:', document.querySelector('.main-layout').getBoundingClientRect().width);
                console.log('sidebar 너비:', this.sidebar.getBoundingClientRect().width);
                console.log('main-content 너비:', this.mainContent.getBoundingClientRect().width);

                this.isIconPanelOpen = !this.isIconPanelOpen;
                
                if (this.isIconPanelOpen) {
                    this.sidebar.classList.add('icon-panel-open');
                    
                    // 사이드바가 열리면 PDF 재조정
                    if (!this.isMobile && this.pdf) {
                        this.handleSidebarToggle();
                    }
                    
                    // 모바일에서 백드롭 표시
                    if (this.isMobile) {
                        this.mobileBackdrop.classList.add('show');
                    }
                    
                    // 마지막에 열려있던 탭으로 복원
                    setTimeout(() => {
                        if (!this.isThumbnailsOpen && !this.isFolderOpen) {
                            if (this.isMobile) {
                                if (this.pdf) {
                                    this.openThumbnails();
                                    setTimeout(() => {
                                        this.updateThumbnailSelection();
                                    }, 100);
                                }
                            } else {
                                if (this.lastOpenedSidebarType === 'thumbnails') {
                                    this.openThumbnails();
                                    setTimeout(() => {
                                        this.updateThumbnailSelection();
                                    }, 100);
                                } else {
                                    this.openFolder();
                                }
                            }
                        }
                    }, 150);
                } else {
                    this.sidebar.classList.remove('icon-panel-open');
                    
                    // 모바일에서 백드롭 숨기기
                    if (this.isMobile) {
                        this.mobileBackdrop.classList.remove('show');
                    }
                    
                    // 현재 열려있는 탭을 기억
                    if (this.isThumbnailsOpen) {
                        this.lastOpenedSidebarType = 'thumbnails';
                    } else if (this.isFolderOpen) {
                        this.lastOpenedSidebarType = 'folder';
                    }
                    
                    // 아이콘 패널이 닫히면 모든 섹션도 닫기
                    this.closeThumbnails();
                    this.closeFolder();
                    
                    // 사이드바가 닫히면 PDF 재조정
                    if (!this.isMobile && this.pdf) {
                        this.handleSidebarToggle();
                    }
                }

                // 여기에 추가! (함수의 맨 끝 부분)
                setTimeout(() => {
                    console.log('=== 사이드바 토글 후 ===');
                    console.log('main-layout 너비:', document.querySelector('.main-layout').getBoundingClientRect().width);
                    console.log('sidebar 너비:', this.sidebar.getBoundingClientRect().width);
                    console.log('main-content 너비:', this.mainContent.getBoundingClientRect().width);
                }, 100);
            }

            // 썸네일 토글 - 개선된 버전
            toggleThumbnails() {
                // 썸네일 버튼이 비활성화되어 있으면 동작하지 않음
                if (this.thumbnailsBtn.disabled) {
                    return;
                }
                
                if (!this.isIconPanelOpen) {
                    this.toggleIconPanel(); // 아이콘 패널이 닫혀있으면 먼저 열기
                    return;
                }
                
                // 이미 썸네일이 열려있는 상태에서 다시 클릭하면 썸네일 창 열기
                if (this.isThumbnailsOpen) {
                    this.openThumbnailWindow();
                    return;
                }
                
                // 다른 섹션이 열려있으면 닫기
                if (this.isFolderOpen) {
                    this.closeFolder();
                }
                
                // 썸네일 열기
                this.openThumbnails();
                
                // 사이드바 변화 시 항상 재계산 (중앙 정렬 유지)
                if (!this.isMobile) {
                    setTimeout(() => {
                        this.adjustScaleForSidebarChange();
                    }, 100); // 썸네일 열기 애니메이션 중간에 재계산
                }
                
                // 썸네일을 열 때 현재 페이지 선택 상태 업데이트
                setTimeout(() => {
                    this.updateThumbnailSelection();
                }, 100); // 애니메이션 완료 후 업데이트
            }

            // 폴더 탐색기 토글 (데스크톱만)
            toggleFolder() {
                if (this.isMobile) return; // 모바일에서는 동작하지 않음
                
                if (!this.isIconPanelOpen) {
                    this.toggleIconPanel(); // 아이콘 패널이 닫혀있으면 먼저 열기
                    return;
                }
                
                // 폴더가 이미 열려있으면 아무것도 하지 않음
                if (this.isFolderOpen) {
                    return;
                }
                
                // 다른 섹션이 열려있으면 닫기
                if (this.isThumbnailsOpen) {
                    this.closeThumbnails();
                }
                
                // 폴더 탐색기 열기
                this.openFolder();
                
                // 사이드바 변화 시 항상 재계산 (중앙 정렬 유지)
                if (!this.isMobile) {
                    setTimeout(() => {
                        this.adjustScaleForSidebarChange();
                    }, 100); // 폴더 열기 애니메이션 중간에 재계산
                }
            }

            // 폴더 탐색기 열기
            openFolder() {
                this.isFolderOpen = true;
                this.currentSidebarType = 'folder';
                this.sidebar.classList.add('folder-open');
                this.folderBtn.classList.add('active');
                this.lastOpenedSidebarType = 'folder'; // 마지막 열린 탭 업데이트
            }

            // 폴더 탐색기 닫기
            closeFolder() {
                this.isFolderOpen = false;
                this.sidebar.classList.remove('folder-open');
                this.folderBtn.classList.remove('active');
            }

            // 폴더 선택 처리 (데스크톱만)
            async handleFolderSelect(event) {
                if (this.isMobile) return; // 모바일에서는 처리하지 않음
                
                const files = Array.from(event.target.files);
                if (files.length === 0) return;

                console.log('선택된 파일들:', files.length);
                
                // 폴더명 추출 (첫 번째 파일의 경로에서)
                const firstFile = files[0];
                const pathParts = firstFile.webkitRelativePath.split('/');
                const folderName = pathParts[0]; // 첫 번째 부분이 폴더명
                this.currentFolderName = folderName;

                // 폴더 제목 업데이트
                this.updateFolderTitle(folderName);

                // 폴더 구조 생성 (모든 파일과 폴더 포함)
                this.buildFolderStructure(files);
                
                // PDF 파일 개수 확인
                const pdfFiles = files.filter(file => file.type === 'application/pdf');
                
                // 폴더 선택 완료 메시지 표시
                this.showFolderSelectedMessage();
                
                // 아이콘 패널이 안 열려있으면 열기
                if (!this.isIconPanelOpen) {
                    this.toggleIconPanel();
                    // 애니메이션 시간을 기다린 후 폴더 탭 열기
                    setTimeout(() => {
                        this.openFolder();
                        this.renderFolderTree();
                    }, 200);
                } else {
                    // 이미 열려있으면 바로 폴더 탭 열기
                    this.openFolder();
                    this.renderFolderTree();
                }
                
                if (pdfFiles.length > 0) {
                    this.showToastMessage(`✅ ${pdfFiles.length}개의 PDF 파일을 찾았습니다`);
                } else {
                    this.showToastMessage('📁 폴더 구조를 로드했습니다 (PDF 파일 없음)');
                }
            }

            // 폴더 제목 업데이트 메서드 추가
            updateFolderTitle(folderName) {
                if (this.isMobile) {
                    this.folderTitle.textContent = '📁 파일 선택';
                } else if (folderName) {
                    this.folderTitle.textContent = `📁 ${folderName}`;
                } else {
                    this.folderTitle.textContent = '📁 폴더 탐색기';
                }
            }

            // 폴더 구조 생성 - 모든 폴더 표시, PDF 파일만 필터링 (데스크톱만)
            buildFolderStructure(files) {
                if (this.isMobile) return; // 모바일에서는 처리하지 않음
                
                const structure = {
                    name: this.currentFolderName || '선택된 폴더',
                    type: 'folder',
                    children: {},
                    files: [],
                    expanded: true
                };

                console.log('폴더 구조 생성 시작, 파일 개수:', files.length);

                // 먼저 모든 폴더 구조를 생성
                const folderSet = new Set();
                
                files.forEach(file => {
                    const pathParts = file.webkitRelativePath.split('/');
                    
                    // 폴더 경로들을 수집 (파일명 제외)
                    for (let i = 1; i < pathParts.length - 1; i++) {
                        const folderPath = pathParts.slice(0, i + 1).join('/');
                        folderSet.add(folderPath);
                    }
                });

                // 폴더 구조 생성
                folderSet.forEach(folderPath => {
                    const pathParts = folderPath.split('/');
                    let current = structure;

                    for (let i = 1; i < pathParts.length; i++) {
                        const folderName = pathParts[i];
                        
                        if (!current.children[folderName]) {
                            current.children[folderName] = {
                                name: folderName,
                                type: 'folder',
                                children: {},
                                files: [],
                                expanded: false
                            };
                            console.log(`  새 폴더 생성: "${folderName}"`);
                        }
                        current = current.children[folderName];
                    }
                });

                // 이제 PDF 파일들만 추가
                files.forEach(file => {
                    // PDF 파일만 처리
                    if (file.type !== 'application/pdf') {
                        return;
                    }

                    const pathParts = file.webkitRelativePath.split('/');
                    let current = structure;

                    // 폴더 경로 따라가기 (파일명 제외)
                    for (let i = 1; i < pathParts.length - 1; i++) {
                        const folderName = pathParts[i];
                        current = current.children[folderName];
                    }

                    // PDF 파일 추가
                    const fileName = pathParts[pathParts.length - 1];
                    console.log(`  PDF 파일 "${fileName}"을 현재 위치에 추가`);
                    
                    current.files.push({
                        name: fileName,
                        type: 'file',
                        file: file,
                        path: file.webkitRelativePath
                    });
                });

                this.folderStructure = structure;
                console.log('최종 폴더 구조:', structure);
            }

            // 드롭된 파일들로 폴더 구조 생성 (데스크톱만)
            buildFolderStructureFromDroppedFiles(files) {
                if (this.isMobile) return; // 모바일에서는 처리하지 않음
                
                const structure = {
                    name: '드롭된 파일들',
                    type: 'folder',
                    children: {},
                    files: [],
                    expanded: true
                };

                files.forEach(file => {
                    // 드롭된 파일들은 경로가 없으므로 루트에 직접 추가
                    structure.files.push({
                        name: file.name,
                        type: 'file',
                        file: file,
                        path: file.name
                    });
                });

                this.folderStructure = structure;
                this.currentFolderName = '드롭된 파일들';
                this.updateFolderTitle(this.currentFolderName);
            }

            // 폴더 트리 렌더링 - 루트 폴더는 표시하지 않고 내용만 렌더링
            renderFolderTree() {
                if (!this.folderStructure) {
                    const emptyText = this.isMobile ? '📁 파일을 선택하거나 PDF 파일들을 여기로 드래그하세요' : '📁 폴더를 선택하거나 PDF 파일들을 여기로 드래그하세요';
                    this.folderTree.innerHTML = `<div class="folder-empty" id="folderEmptyArea">${emptyText}</div>`;
                    
                    // 빈 영역 클릭 이벤트 추가
                    const emptyArea = document.getElementById('folderEmptyArea');
                    if (emptyArea) {
                        emptyArea.addEventListener('click', (e) => {
                            if (this.isMobile) {
                                this.fileInput.click();
                                if (this.isIconPanelOpen) {
                                    this.toggleIconPanel();
                                }
                            } else {
                                this.openFolderDialog(e);
                            }
                        });
                        
                        // 드래그 앤 드롭 이벤트 추가 (데스크톱만)
                        if (!this.isMobile) {
                            emptyArea.addEventListener('dragover', (e) => {
                                e.preventDefault();
                                emptyArea.classList.add('dragover');
                            });
                            
                            emptyArea.addEventListener('dragleave', () => {
                                emptyArea.classList.remove('dragover');
                            });
                            
                            emptyArea.addEventListener('drop', (e) => {
                                e.preventDefault();
                                emptyArea.classList.remove('dragover');
                                
                                const files = Array.from(e.dataTransfer.files);
                                const pdfFiles = files.filter(file => file.type === 'application/pdf');
                                
                                if (pdfFiles.length > 0) {
                                    // 가상의 폴더 구조 생성 (드롭된 파일들로)
                                    this.buildFolderStructureFromDroppedFiles(pdfFiles);
                                    this.renderFolderTree();
                                    this.showToastMessage(`✅ ${pdfFiles.length}개의 PDF 파일을 추가했습니다`);
                                } else {
                                    this.showToastMessage('❌ PDF 파일만 드롭할 수 있습니다');
                                }
                            });
                        }
                    }
                    return;
                }

                this.folderTree.innerHTML = '';
                
                // 루트 폴더의 내용만 렌더링 (루트 폴더 자체는 표시하지 않음)
                this.renderFolderContents(this.folderStructure, this.folderTree, -1); // depth를 -1로 시작해서 실제 내용이 0부터 시작되도록
            }

            // 폴더 내용 렌더링 (루트 폴더 자체는 렌더링하지 않고 내용만)
            renderFolderContents(node, container, depth) {
                // 하위 폴더들 먼저 렌더링
                Object.values(node.children)
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .forEach(child => {
                        this.renderFolderNode(child, container, depth + 1);
                    });

                // 그 다음 파일들 렌더링
                node.files
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .forEach(fileNode => {
                        this.renderFileNode(fileNode, container, depth + 1);
                    });
            }

            // 폴더 노드 렌더링
            renderFolderNode(node, container, depth) {
                if (node.type === 'folder') {
                    // 폴더 아이템 생성
                    const folderItem = document.createElement('div');
                    folderItem.className = 'folder-item';
                    folderItem.style.paddingLeft = (depth * 16 + 4) + 'px';

                    // 모든 폴더를 상호작용 가능하게 만들기
                    folderItem.innerHTML = `
                        <span class="folder-icon expandable" data-action="toggle">
                            ${node.expanded ? '📂' : '📁'}
                        </span>
                        <span class="folder-name">${node.name}</span>
                    `;

                    // 모든 폴더에 클릭 이벤트 (열기/닫기)
                    folderItem.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // 모든 폴더 토글 가능
                        node.expanded = !node.expanded;
                        this.renderFolderTree();
                    });

                    container.appendChild(folderItem);

                    // 확장된 폴더의 자식들 렌더링 (자식이 있을 때만)
                    if (node.expanded) {
                        const hasSubfolders = Object.keys(node.children).length > 0;
                        const hasPdfFiles = node.files.length > 0;
                        
                        if (hasSubfolders || hasPdfFiles) {
                            // 하위 폴더들 먼저
                            Object.values(node.children)
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .forEach(child => {
                                    this.renderFolderNode(child, container, depth + 1);
                                });

                            // 그 다음 파일들 (PDF만)
                            node.files
                                .sort((a, b) => a.name.localeCompare(b.name))
                                .forEach(fileNode => {
                                    this.renderFileNode(fileNode, container, depth + 1);
                                });
                        } else {
                            // 빈 폴더 표시
                            const emptyItem = document.createElement('div');
                            emptyItem.className = 'folder-item';
                            emptyItem.style.paddingLeft = ((depth + 1) * 16 + 4) + 'px';
                            emptyItem.style.color = '#888';
                            emptyItem.innerHTML = `
                                <span class="folder-icon">📭</span>
                                <span class="folder-name">(빈 폴더)</span>
                            `;
                            container.appendChild(emptyItem);
                        }
                    }
                }
            }

            // 파일 노드 렌더링
            renderFileNode(fileNode, container, depth) {
                const fileItem = document.createElement('div');
                fileItem.className = 'folder-item pdf-file';
                fileItem.style.paddingLeft = (depth * 16 + 4) + 'px';
                fileItem.dataset.filePath = fileNode.path;

                fileItem.innerHTML = `
                    <span class="folder-icon">📄</span>
                    <span class="folder-name" title="${fileNode.name}">${fileNode.name}</span>
                `;

                // 파일 전체 라인에 클릭 이벤트
                fileItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.selectFileInTree(fileItem);
                    this.handleFile(fileNode.file);
                    
                    // 브라우저 탭 제목도 파일명으로 업데이트
                    document.title = fileNode.name;
                    
                    // 모바일에서는 파일 선택 후 사이드바 닫기
                    if (this.isMobile && this.isIconPanelOpen) {
                        this.toggleIconPanel();
                    }
                });

                container.appendChild(fileItem);
            }

            // 트리에서 파일 선택
            selectFileInTree(fileItem) {
                // 기존 선택 해제
                const previousSelected = this.folderTree.querySelector('.folder-item.selected');
                if (previousSelected) {
                    previousSelected.classList.remove('selected');
                }

                // 새로운 파일 선택
                fileItem.classList.add('selected');
                this.selectedFile = fileItem.dataset.filePath;
            }

            // 썸네일 열기
            openThumbnails() {
                this.isThumbnailsOpen = true;
                this.thumbnailMode = 'sidebar';
                this.sidebar.classList.add('thumbnails-open');
                this.thumbnailsBtn.classList.add('active');
                this.lastOpenedSidebarType = 'thumbnails'; // 마지막 열린 탭 업데이트
                
                // 아이콘 변경 (사이드바 모드)
                this.thumbnailsBtn.textContent = '🖼️';
                this.thumbnailsBtn.title = '축소판 창 열기';
            }

            // 썸네일 닫기
            closeThumbnails() {
                this.isThumbnailsOpen = false;
                this.thumbnailMode = 'none';
                this.sidebar.classList.remove('thumbnails-open');
                this.thumbnailsBtn.classList.remove('active');
                
                // 아이콘 복원
                this.thumbnailsBtn.textContent = '🖼️';
                this.thumbnailsBtn.title = '페이지 썸네일';
            }

            // 사이드바 변화에 따른 배율 재조정 (데스크톱만)
            async adjustScaleForSidebarChange() {
                if (!this.pdf || this.isMobile) return;
                
                // 레이아웃 안정화 대기
                await new Promise(resolve => setTimeout(resolve, 100));
                
                this.startZooming();
                
                try {
                    const page = await this.pdf.getPage(this.currentPage);
                    
                    if (this.fitMode === 'width') {
                        const newScale = await this.calculateFitToWidthScale(page);
                        this.scale = newScale;
                        this.updateUI();
                        this.updateImageSize();
                        // maintainPDFCenter 호출 제거 (toggleIconPanel에서 한 번만 호출)
                    } else if (this.fitMode === 'page') {
                        const newScale = await this.calculateFitToPageScale(page);
                        this.scale = newScale;
                        this.updateUI();
                        this.updateImageSize();
                    }
                    
                } catch (error) {
                    console.error('배율 재조정 실패:', error);
                } finally {
                    this.isZooming = false;
                }
            }

            // PDF 페이지 렌더링
            async renderPage(renderTextLayer = true) {
                if (!this.pdf) return;

                // 이전 렌더링 작업 취소
                await this.cancelCurrentRender();

                const page = await this.pdf.getPage(this.currentPage);
                
                // 기존 텍스트 레이어 클리어
                this.clearTextLayer();
                
                // 맞춤 모드에 따른 스케일 계산
                if (this.fitMode === 'width') {
                    await this.calculateFitToWidth(page);
                } else if (this.fitMode === 'page') {
                    await this.calculateFitToPage(page);
                }
                
                const displayViewport = page.getViewport({scale: this.scale});
                
                // 이미지로 렌더링
                await this.renderAsImage(page, displayViewport);
                
                // 스크롤 영역 업데이트
                this.updateScrollArea(displayViewport);
                
                // 텍스트 레이어 렌더링
                if (renderTextLayer) {
                    this.scheduleTextLayerRender(page, displayViewport);
                }

                // 렌더링 후 중앙 정렬 확인
                setTimeout(() => {
                    this.maintainPDFCenter();
                }, 50);

                // 스크롤 영역 강제 업데이트
                requestAnimationFrame(() => {
                    this.pdfContainer.dispatchEvent(new Event('scroll'));
                    
                    // 추가: 확대된 상태에서 스크롤 영역 재확인
                    if (this.scale > 1.0 && this.fitMode === 'none') {
                        this.ensureScrollAreaCorrect();
                    }
                });
            }

            async renderAsImage(page, displayViewport) {
                // Promise로 이미지 로딩 과정을 감싸서,
                // 이미지가 완전히 로드 및 렌더링될 때까지 기다릴 수 있도록 합니다.
                return new Promise(async (resolve, reject) => {
                    try {
                        // 현재 페이지의 실제 크기 저장
                        const originalViewport = page.getViewport({scale: 1.0});
                        this.originalPageWidth = originalViewport.width;
                        this.originalPageHeight = originalViewport.height;

                        // 고품질 렌더링을 위한 캔버스 설정
                        const highQualityScale = this.scale * this.renderScale;
                        const highQualityViewport = page.getViewport({scale: highQualityScale});
                        
                        this.canvas.width = highQualityViewport.width;
                        this.canvas.height = highQualityViewport.height;
                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                        const renderContext = {
                            canvasContext: this.ctx,
                            viewport: highQualityViewport
                        };
                        
                        this.currentRenderTask = page.render(renderContext);
                        await this.currentRenderTask.promise;
                        
                        const imageDataUrl = this.canvas.toDataURL('image/png', 1.0);
                        
                        // *** 핵심 변경 부분: onload 이벤트 핸들러 설정 ***
                        this.pdfImage.onload = () => {
                            this.pdfImage.onload = null; // 핸들러 정리
                            this.pdfImage.onerror = null;
                            resolve(); // Promise를 이행하여 다음 코드가 실행되게 함
                        };

                        this.pdfImage.onerror = () => {
                            this.pdfImage.onload = null;
                            this.pdfImage.onerror = null;
                            console.error("Image failed to load from data URL.");
                            reject(new Error("Image loading failed")); // Promise를 거부
                        };
                        
                        // 이미지 src를 설정하여 로딩 시작
                        this.pdfImage.src = imageDataUrl;
                        
                        // 크기 설정은 즉시 해도 됩니다.
                        this.pdfImage.style.width = displayViewport.width + 'px';
                        this.pdfImage.style.height = displayViewport.height + 'px';
                        this.textLayer.style.width = displayViewport.width + 'px';
                        this.textLayer.style.height = displayViewport.height + 'px';
                        
                        this.currentRenderTask = null;

                    } catch (error) {
                        if (error.name === 'RenderingCancelledException') {
                            console.log('렌더링이 취소되었습니다.');
                            resolve(); // 취소도 성공적으로 처리
                        } else {
                            console.error('이미지 렌더링 실패:', error);
                            reject(error); // 실제 오류는 거부
                        }
                        this.currentRenderTask = null;
                    }
                });
            }

            updateScrollArea(viewport) {
                const pdfWidth = this.originalPageWidth * this.scale;
                const pdfHeight = this.originalPageHeight * this.scale;
                const margin = 20;
                
                const containerWidth = this.pdfContainer.clientWidth;
                const containerHeight = this.pdfContainer.clientHeight;
                
                // 페이지 맞춤 모드
                if (this.fitMode === 'page') {
                    // PDF 실제 크기로 wrapper 설정 (scaledWidth/Height 대신 pdfWidth/Height 사용)
                    this.pdfWrapper.style.width = pdfWidth + 'px';
                    this.pdfWrapper.style.height = pdfHeight + 'px';
                    this.pdfWrapper.style.justifyContent = 'center';
                    this.pdfWrapper.style.alignItems = 'center';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.padding = '0';
                    this.pdfWrapper.style.margin = '0 auto'; // 중앙 정렬
                    this.pdfWrapper.style.minWidth = 'unset';
                    this.pdfWrapper.style.minHeight = 'unset';
                    this.pdfWrapper.style.boxSizing = 'content-box';
                }
                // 너비 맞춤 모드
                else if (this.fitMode === 'width') {
                    console.log('=== 너비 맞춤 모드 상세 디버깅 시작 ===');
                    console.log('PDF 크기:', { pdfWidth, pdfHeight });
                    console.log('컨테이너 크기:', { containerWidth, containerHeight });
                    console.log('여백:', margin);
                    
                    this.pdfWrapper.style.boxSizing = 'content-box';
                    this.pdfWrapper.style.width = '100%';
                    this.pdfWrapper.style.height = 'auto';
                    this.pdfWrapper.style.minHeight = Math.max(pdfHeight + margin * 2, containerHeight) + 'px';
                    this.pdfWrapper.style.justifyContent = 'center';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.padding = `${margin/2}px 0`;
                    
                    // **핵심 수정: PDF 높이에 따른 조건부 정렬**
                    const shouldCenter = pdfHeight < containerHeight;
                    console.log('중앙 정렬 조건:', { 
                        pdfHeight, 
                        containerHeight, 
                        shouldCenter,
                        heightDifference: containerHeight - pdfHeight 
                    });
                    
                    if (shouldCenter) {
                        // PDF가 컨테이너보다 작으면 중앙 정렬
                        this.pdfWrapper.style.alignItems = 'center';
                        console.log('✓ 너비 맞춤 - PDF가 작아서 중앙 정렬 적용');
                    } else {
                        // PDF가 컨테이너보다 크면 상단 정렬
                        this.pdfWrapper.style.alignItems = 'flex-start';
                        console.log('✓ 너비 맞춤 - PDF가 커서 상단 정렬 적용');
                    }
                    
                    // **PDF 콘텐츠 margin 초기화**
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.pdfContent.style.marginBottom = '0';
                    
                    // 적용된 스타일 확인
                    console.log('적용된 wrapper 스타일:', {
                        width: this.pdfWrapper.style.width,
                        height: this.pdfWrapper.style.height,
                        minHeight: this.pdfWrapper.style.minHeight,
                        alignItems: this.pdfWrapper.style.alignItems,
                        justifyContent: this.pdfWrapper.style.justifyContent,
                        padding: this.pdfWrapper.style.padding
                    });
                    
                    // 실제 DOM 계산 값 확인
                    setTimeout(() => {
                        const wrapperRect = this.pdfWrapper.getBoundingClientRect();
                        const contentRect = this.pdfContent.getBoundingClientRect();
                        const imageRect = this.pdfImage.getBoundingClientRect();
                        
                        console.log('실제 DOM 위치:', {
                            wrapper: { 
                                top: wrapperRect.top, 
                                height: wrapperRect.height,
                                bottom: wrapperRect.bottom 
                            },
                            content: { 
                                top: contentRect.top, 
                                height: contentRect.height,
                                bottom: contentRect.bottom 
                            },
                            image: { 
                                top: imageRect.top, 
                                height: imageRect.height,
                                bottom: imageRect.bottom 
                            },
                            containerScroll: {
                                scrollTop: this.pdfContainer.scrollTop,
                                scrollHeight: this.pdfContainer.scrollHeight,
                                clientHeight: this.pdfContainer.clientHeight
                            }
                        });
                    }, 100);
                    
                    console.log('=== 너비 맞춤 모드 상세 디버깅 완료 ===');
                }
                // 기본 모드 (확대/축소)
                // updateScrollArea 함수에서 기본 모드(else) 부분을 다음으로 교체
                else {
                    // 기본 모드 (확대/축소)
                    const margin = 20;
                    const wrapperWidth = pdfWidth + margin * 2;
                    const wrapperHeight = pdfHeight + margin * 2;
                    
                    this.pdfWrapper.style.width = Math.max(wrapperWidth, containerWidth) + 'px';
                    this.pdfWrapper.style.height = Math.max(wrapperHeight, containerHeight) + 'px';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.justifyContent = 'center';
                    
                    // 개선된 정렬 방식 - padding 대신 margin 사용
                    if (pdfHeight > containerHeight) {
                        // 세로 스크롤이 필요한 경우: 위쪽 정렬하되 margin으로 여백 확보
                        this.pdfWrapper.style.alignItems = 'flex-start';
                        this.pdfWrapper.style.padding = '0';
                        this.pdfWrapper.style.boxSizing = 'border-box';
                        
                        // PDF content에 상단 margin 적용
                        this.pdfContent.style.marginTop = `${margin}px`;
                        this.pdfContent.style.marginBottom = `${margin}px`;
                    } else {
                        // 세로 스크롤이 없는 경우: 중앙 정렬
                        this.pdfWrapper.style.alignItems = 'center';
                        this.pdfWrapper.style.padding = '0';
                        this.pdfContent.style.margin = '0';
                    }
                }
                
                // 스크롤 영역 강제 업데이트
                this.pdfContainer.offsetHeight;
            }

            async cancelCurrentRender() {
                // 현재 진행 중인 렌더링 작업이 있으면 취소
                if (this.currentRenderTask) {
                    try {
                        this.currentRenderTask.cancel();
                    } catch (error) {
                        console.log('렌더링 취소 시도:', error.message);
                    }
                    this.currentRenderTask = null;
                }
            }

            scheduleTextLayerRender(page, viewport) {
                // 기존 텍스트 레이어 렌더링 타이머 취소
                if (this.textLayerTimeout) {
                    clearTimeout(this.textLayerTimeout);
                }
                
                // 100ms 후에 텍스트 레이어 렌더링
                this.textLayerTimeout = setTimeout(async () => {
                    if (!this.isZooming) {
                        await this.renderTextLayer(page, viewport);
                    }
                }, 100);
            }

            async clearTextLayer() {
                // 모든 타이머 취소
                if (this.textLayerTimeout) {
                    clearTimeout(this.textLayerTimeout);
                    this.textLayerTimeout = null;
                }
                
                // 기존 선택 해제
                if (window.getSelection) {
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                }
                
                // 텍스트 레이어 완전히 클리어
                const textLayer = this.textLayer;
                
                while (textLayer.hasChildNodes()) {
                    textLayer.removeChild(textLayer.firstChild);
                }
                
                textLayer.innerHTML = '';
                textLayer.textContent = '';
                textLayer.offsetHeight; // 강제 리플로우
            }

            async renderTextLayer(page, viewport) {
                try {
                    // 텍스트 콘텐츠 가져오기
                    const textContent = await page.getTextContent();
                    
                    if (!textContent || !textContent.items || textContent.items.length === 0) {
                        return;
                    }
                    
                    // 텍스트 아이템들을 Y 위치별로 그룹화 (라인별로)
                    const lines = [];
                    
                    textContent.items.forEach((textItem) => {
                        if (!textItem.str || textItem.str.trim() === '') return;
                        
                        const transform = textItem.transform;
                        if (!transform || transform.length < 6) return;
                        
                        const y = transform[5];
                        const fontSize = textItem.height || Math.sqrt(transform[2] * transform[2] + transform[3] * transform[3]);
                        
                        // 같은 라인으로 간주할 Y 위치 범위
                        const tolerance = fontSize * 0.5;
                        
                        let foundLine = lines.find(line => Math.abs(line.y - y) < tolerance);
                        
                        if (!foundLine) {
                            foundLine = {
                                y: y,
                                fontSize: fontSize,
                                items: []
                            };
                            lines.push(foundLine);
                        }
                        
                        foundLine.items.push({
                            ...textItem,
                            x: transform[4],
                            y: y,
                            fontSize: fontSize
                        });
                    });
                    
                    // 각 라인별로 처리
                    lines.forEach(line => {
                        // X 위치순으로 정렬
                        line.items.sort((a, b) => a.x - b.x);
                        
                        // 연속된 텍스트들을 그룹화
                        const groups = [];
                        let currentGroup = null;
                        
                        line.items.forEach((item, index) => {
                            if (!currentGroup) {
                                currentGroup = {
                                    x: item.x,
                                    y: item.y,
                                    fontSize: item.fontSize,
                                    text: item.str,
                                    width: item.width || item.str.length * item.fontSize * 0.6,
                                    transform: item.transform
                                };
                                groups.push(currentGroup);
                            } else {
                                const currentEnd = currentGroup.x + currentGroup.width;
                                const itemStart = item.x;
                                const gap = itemStart - currentEnd;
                                
                                // 간격이 작으면 현재 그룹에 추가, 크면 새 그룹 생성
                                if (gap < item.fontSize * 0.8) {
                                    // 공백 추가 여부 결정
                                    if (gap > item.fontSize * 0.2) {
                                        currentGroup.text += ' ';
                                    }
                                    currentGroup.text += item.str;
                                    currentGroup.width = itemStart + (item.width || item.str.length * item.fontSize * 0.6) - currentGroup.x;
                                } else {
                                    // 새 그룹 시작
                                    currentGroup = {
                                        x: item.x,
                                        y: item.y,
                                        fontSize: item.fontSize,
                                        text: item.str,
                                        width: item.width || item.str.length * item.fontSize * 0.6,
                                        transform: item.transform
                                    };
                                    groups.push(currentGroup);
                                }
                            }
                        });
                        
                        // 각 그룹별로 span 생성
                        groups.forEach(group => {
                            if (group.text.trim() === '') return;
                            
                            const span = document.createElement('span');
                            
                            // PDF 좌표를 화면 좌표로 변환
                            const screenX = group.x * viewport.scale;
                            const screenY = (viewport.height / viewport.scale - group.y - group.fontSize) * viewport.scale;
                            
                            // 스타일 적용
                            span.style.position = 'absolute';
                            span.style.left = screenX + 'px';
                            span.style.top = screenY + 'px';
                            span.style.fontSize = (group.fontSize * viewport.scale) + 'px';
                            span.style.fontFamily = 'serif';
                            span.style.color = 'transparent';
                            span.style.cursor = 'text';
                            span.style.userSelect = 'text';
                            span.style.webkitUserSelect = 'text';
                            span.style.mozUserSelect = 'text';
                            span.style.pointerEvents = 'auto';
                            span.style.whiteSpace = 'pre';
                            span.style.transformOrigin = '0 0';
                            
                            // 텍스트 내용 설정
                            span.textContent = group.text;
                            
                            // 회전 처리
                            const transform = group.transform;
                            if (Math.abs(transform[1]) > 0.001 || Math.abs(transform[2]) > 0.001) {
                                const angle = Math.atan2(transform[1], transform[0]) * (180 / Math.PI);
                                span.style.transform = `rotate(${angle}deg)`;
                            }
                            
                            this.textLayer.appendChild(span);
                        });
                    });
                    
                } catch (error) {
                    console.error('텍스트 레이어 렌더링 실패:', error);
                }
            }

            async calculateFitToWidth(page) {
                // 실제 PDF 컨테이너의 너비를 직접 측정
                const containerRect = this.pdfContainer.getBoundingClientRect();
                const availableWidth = containerRect.width;
                
                // 현재 페이지의 실제 크기 가져오기
                const viewport = page.getViewport({scale: 1.0});
                const pageWidth = viewport.width;
                
                // 여백 계산 (스크롤바와 패딩 고려)
                const safeMargin = this.isMobile ? 20 : 40;
                this.scale = Math.max(0.25, (availableWidth - safeMargin) / pageWidth);
            }

            async calculateFitToPage(page) {
                console.log('=== CALCULATE FIT TO PAGE 시작 ===');
                const containerWidth = this.pdfContainer.clientWidth;
                const containerHeight = this.pdfContainer.clientHeight;
                
                console.log('컨테이너 크기:', { containerWidth, containerHeight });
                
                // 현재 페이지의 실제 크기 가져오기
                const viewport = page.getViewport({scale: 1.0});
                const pageWidth = viewport.width;
                const pageHeight = viewport.height;
                
                console.log('페이지 원본 크기:', { pageWidth, pageHeight });
                
                // 페이지 맞춤 모드에서는 최소한의 여백만 확보하여 화면을 최대한 활용
                const safeMargin = this.isMobile ? 10 : 20; // 모바일에서는 더 작은 여백
                const scaleX = (containerWidth - safeMargin) / pageWidth;
                const scaleY = (containerHeight - safeMargin) / pageHeight;
                this.scale = Math.min(scaleX, scaleY);
                
                console.log('스케일 계산:', {
                    safeMargin,
                    scaleX,
                    scaleY,
                    finalScale: this.scale
                });
                console.log('=== CALCULATE FIT TO PAGE 완료 ===');
            }

            async toggleFit() {
                console.log('=== TOGGLE FIT 시작 ===');
                console.log('현재 fitMode:', this.fitMode);
                console.log('현재 스케일:', this.scale);
                
                this.startZooming();
                
                // 현재 모드에 따라 다음 모드로 전환
                const newFitMode = this.fitMode === 'page' ? 'width' : 'page';
                console.log('새로운 fitMode:', newFitMode);
                
                // 맞춤 모드를 위한 스케일 계산
                if (!this.pdf) return;
                const page = await this.pdf.getPage(this.currentPage);
                
                let newScale;
                if (newFitMode === 'width') {
                    newScale = await this.calculateFitToWidthScale(page);
                    console.log('너비 맞춤 스케일 계산:', newScale);
                } else {
                    newScale = await this.calculateFitToPageScale(page);
                    console.log('페이지 맞춤 스케일 계산:', newScale);
                }
                
                console.log('performZoom 호출 - 스케일:', newScale, 'fitMode:', newFitMode);
                await this.performZoom(newScale, newFitMode);
                console.log('=== TOGGLE FIT 완료 ===');
            }

            async calculateFitToWidthScale(page) {
                // 실제 PDF 컨테이너의 너비를 직접 측정
                const containerRect = this.pdfContainer.getBoundingClientRect();
                const availableWidth = containerRect.width;
                
                // 현재 페이지의 실제 크기 가져오기
                const viewport = page.getViewport({scale: 1.0});
                const pageWidth = viewport.width;
                
                // 여백 계산 (스크롤바와 패딩 고려)
                const safeMargin = this.isMobile ? 20 : 40;
                return Math.max(0.25, (availableWidth - safeMargin) / pageWidth);
            }

            async calculateFitToPageScale(page) {
                const containerWidth = this.pdfContainer.clientWidth;
                const containerHeight = this.pdfContainer.clientHeight;
                
                // 현재 페이지의 실제 크기 가져오기
                const viewport = page.getViewport({scale: 1.0});
                const pageWidth = viewport.width;
                const pageHeight = viewport.height;
                
                // 페이지 맞춤 모드에서는 여백을 최소화하여 화면을 최대한 활용
                const safeMargin = this.isMobile ? 5 : 10; // 여백을 더 줄임
                const scaleX = (containerWidth - safeMargin) / pageWidth;
                const scaleY = (containerHeight - safeMargin) / pageHeight;
                const calculatedScale = Math.min(scaleX, scaleY);
                
                console.log('페이지 맞춤 계산:', {
                    containerWidth,
                    containerHeight, 
                    pageWidth,
                    pageHeight,
                    scaleX,
                    scaleY,
                    finalScale: calculatedScale
                });
                
                return Math.max(0.1, calculatedScale); // 최소 스케일 보장
            }

            updateFitToggle() {
                // 현재 fitMode에 따라 버튼 아이콘과 상태 변경
                if (this.fitMode === 'page') {
                    this.fitToggleBtn.textContent = '↔️'; // 페이지 맞춤 상태, 클릭하면 너비 맞춤으로
                    this.fitToggleBtn.classList.add('active');
                    this.fitToggleBtn.title = '너비에 맞춤으로 전환';
                    // 페이지 맞춤 모드에서는 스크롤 완전 금지
                    this.pdfContainer.classList.add('fit-page');
                    this.pdfContainer.classList.remove('fit-width');
                } else if (this.fitMode === 'width') {
                    this.fitToggleBtn.textContent = '↕️'; // 너비 맞춤 상태, 클릭하면 페이지 맞춤으로
                    this.fitToggleBtn.classList.add('active');
                    this.fitToggleBtn.title = '페이지에 맞춤으로 전환';
                    this.pdfContainer.classList.remove('fit-page');
                    this.pdfContainer.classList.add('fit-width'); // 너비 맞춤 CSS 클래스 추가
                } else {
                    this.fitToggleBtn.textContent = '↕️'; // 기본 상태, 클릭하면 페이지 맞춤으로
                    this.fitToggleBtn.classList.remove('active');
                    this.fitToggleBtn.title = '페이지에 맞춤';
                    this.pdfContainer.classList.remove('fit-page');
                    this.pdfContainer.classList.remove('fit-width');
                }
            }

            async setZoomFromSelect() {
                this.startZooming();
                
                const zoomPercent = parseInt(this.zoomSelect.value);
                const newScale = zoomPercent / 100;
                
                await this.performZoom(newScale, 'none');
            }

            async zoomPage(factor) {
                // 현재 스케일에서 새로운 스케일 계산
                let newScale = this.scale * factor;
                const minScale = 0.25;
                const maxScale = 5.0;
                
                // 제한 범위를 벗어나면 동작하지 않음
                if (newScale < minScale || newScale > maxScale) {
                    return;
                }
                
                this.startZooming();
                
                newScale = Math.max(minScale, Math.min(maxScale, newScale));
                
                await this.performZoom(newScale, 'none');
            }

            startZooming() {
                this.isZooming = true;
                this.clearTextLayer();
            }

            async performZoom(newScale, newFitMode) {
                console.log('=== PERFORM ZOOM 시작 ===');
                console.log('입력값:', { newScale, newFitMode });
                console.log('현재 상태:', { 
                    currentFitMode: this.fitMode, 
                    currentScale: this.scale,
                    isFromWidthFit: this.fitMode === 'width' && newFitMode === 'none'
                });
                
                // 현재 컨테이너 중앙 좌표 계산
                const container = this.pdfContainer;
                const containerCenterX = container.clientWidth / 2;
                const containerCenterY = container.clientHeight / 2;
                
                console.log('컨테이너 중앙:', { containerCenterX, containerCenterY });
                
                // **핵심 수정: 맞춤 모드에서 일반 모드로 전환할 때 중앙 기준점 재계산**
                let currentCenterX, currentCenterY;
                
                if ((this.fitMode === 'page' || this.fitMode === 'width') && newFitMode === 'none') {
                    // 맞춤 모드에서 일반 모드로 전환: 화면 중앙을 기준으로 설정
                    console.log('맞춤 모드에서 일반 모드로 전환 - 화면 중앙 기준 적용');
                    currentCenterX = containerCenterX;
                    currentCenterY = containerCenterY;
                } else {
                    // 일반적인 경우: 현재 스크롤 위치 기준
                    currentCenterX = container.scrollLeft + containerCenterX;
                    currentCenterY = container.scrollTop + containerCenterY;
                }
                
                console.log('현재 중앙점:', { currentCenterX, currentCenterY });
                console.log('변경 전 스크롤:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                
                // 스케일 비율 계산
                const scaleRatio = newScale / this.scale;
                console.log('스케일 비율:', scaleRatio, '(', this.scale, '→', newScale, ')');
                
                // 내부 상태 업데이트
                const oldScale = this.scale;
                this.scale = newScale;
                if (newFitMode !== undefined) this.fitMode = newFitMode;
                this.updateFitToggle();
                this.updateUI();
                
                console.log('상태 업데이트 완료:', { oldScale, newScale: this.scale, fitMode: this.fitMode });
                
                // 이미지와 텍스트 레이어를 새로운 스케일로 즉시 업데이트
                this.updateImageSize();
                this.updateScrollAreaForZoom();
                
                console.log('이미지 크기 업데이트 후 스크롤:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                
                // 스크롤 위치 조정 (중앙 기준 유지)
                const newCenterX = currentCenterX * scaleRatio;
                const newCenterY = currentCenterY * scaleRatio;

                const newScrollLeft = newCenterX - containerCenterX;
                const newScrollTop = newCenterY - containerCenterY;

                console.log('새로운 중앙점:', { newCenterX, newCenterY });
                console.log('계산된 스크롤 위치:', { newScrollLeft, newScrollTop });

                // **핵심 수정: 이전 fitMode 상태 저장**
                const previousFitMode = oldScale !== this.scale ? 
                    (this.fitMode === 'page' ? 'page' : this.fitMode === 'width' ? 'width' : 'none') : 'none';

                // 페이지 맞춤 모드에서는 스크롤을 0으로 강제 설정
                if (newFitMode === 'page') {
                    console.log('페이지 맞춤 모드 - 스크롤을 0으로 설정');
                    container.scrollLeft = 0;
                    container.scrollTop = 0;
                } else if (newFitMode === 'width') {
                    console.log('=== performZoom 너비 맞춤 모드 처리 ===');
                    console.log('스크롤 설정 전:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                    
                    container.scrollLeft = 0;
                    container.scrollTop = 0;
                    
                    console.log('스크롤 설정 후:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                    console.log('forceUpdateScrollAreaForWidthFit 호출 예정');
                    
                    setTimeout(() => {
                        this.forceUpdateScrollAreaForWidthFit();
                    }, 50);
                } else {
                    // **핵심 수정: 맞춤 모드에서 일반 모드로 전환 감지 개선**
                    const isTransitionFromWidthFit = (this.fitMode === 'width' || 
                        (newFitMode === 'none' && (newScrollLeft < 0 || newScrollTop < 0))) && newFitMode === 'none';

                    if (isTransitionFromWidthFit) {
                        console.log('너비 맞춤→일반 모드 전환 - 특별 중앙 정렬 처리');
                        
                        // 너비 맞춤에서 일반 모드로 전환할 때는 항상 중앙 정렬
                        this.forceCenterAlignment();
                        
                        // 스크롤을 중앙으로 설정
                        const pdfWidth = this.originalPageWidth * newScale;
                        const pdfHeight = this.originalPageHeight * newScale;
                        
                        if (pdfWidth <= containerWidth && pdfHeight <= containerHeight) {
                            // PDF가 컨테이너보다 작으면 스크롤 없음
                            container.scrollLeft = 0;
                            container.scrollTop = 0;
                            console.log('작은 PDF - 스크롤 없음');
                        } else if (pdfWidth <= containerWidth) {
                            // 가로는 중앙, 세로만 스크롤 가능
                            container.scrollLeft = 0;
                            container.scrollTop = 0; // 상단에서 시작
                            console.log('가로 중앙, 세로 스크롤 가능');
                        } else {
                            // 가로/세로 모두 스크롤 가능 - 중앙에서 시작
                            const centerScrollLeft = Math.max(0, (pdfWidth - containerWidth) / 2);
                            const centerScrollTop = Math.max(0, (pdfHeight - containerHeight) / 2);
                            
                            container.scrollLeft = centerScrollLeft;
                            container.scrollTop = centerScrollTop;
                            console.log('가로/세로 중앙 스크롤:', { centerScrollLeft, centerScrollTop });
                        }
                    } else {
                        // 일반적인 경우
                        container.scrollLeft = Math.max(0, Math.min(newScrollLeft, container.scrollWidth - container.clientWidth));
                        container.scrollTop = Math.max(0, Math.min(newScrollTop, container.scrollHeight - container.clientHeight));
                    }
                }
                
                console.log('최종 스크롤 위치:', { scrollTop: container.scrollTop, scrollLeft: container.scrollLeft });
                
                // 텍스트 레이어 스케일 업데이트 (디바운스)
                this.scheduleTextLayerUpdate();
                
                // 줌 완료
                this.isZooming = false;
                console.log('=== PERFORM ZOOM 완료 ===\n');
            }
            
            // 강제 중앙 정렬 함수 개선
            forceCenterAlignment() {
                console.log('=== 강제 중앙 정렬 시작 ===');
                
                const pdfWidth = this.originalPageWidth * this.scale;
                const pdfHeight = this.originalPageHeight * this.scale;
                const containerWidth = this.pdfContainer.clientWidth;
                const containerHeight = this.pdfContainer.clientHeight;
                const margin = 20;
                
                console.log('중앙 정렬 계산:', {
                    pdfWidth, pdfHeight,
                    containerWidth, containerHeight,
                    scale: this.scale
                });
                
                // wrapper 설정을 명확하게
                const wrapperWidth = Math.max(pdfWidth + margin * 2, containerWidth);
                const wrapperHeight = Math.max(pdfHeight + margin * 2, containerHeight);
                
                this.pdfWrapper.style.width = wrapperWidth + 'px';
                this.pdfWrapper.style.height = wrapperHeight + 'px';
                this.pdfWrapper.style.display = 'flex';
                this.pdfWrapper.style.justifyContent = 'center';
                this.pdfWrapper.style.boxSizing = 'border-box';
                this.pdfWrapper.style.padding = '0';
                
                // PDF 크기에 따른 정렬 방식 결정
                if (pdfHeight <= containerHeight) {
                    // PDF가 세로로 작으면 중앙 정렬
                    this.pdfWrapper.style.alignItems = 'center';
                    this.pdfWrapper.style.minHeight = containerHeight + 'px';
                    console.log('세로 중앙 정렬 적용 (PDF가 작음)');
                } else {
                    // PDF가 세로로 크면 상단 정렬하되 margin 확보
                    this.pdfWrapper.style.alignItems = 'flex-start';
                    this.pdfWrapper.style.paddingTop = margin + 'px';
                    this.pdfWrapper.style.paddingBottom = margin + 'px';
                    this.pdfWrapper.style.minHeight = 'unset';
                    console.log('상단 정렬 적용 (PDF가 큼), margin:', margin);
                }
                
                // PDF content margin 초기화
                this.pdfContent.style.margin = '0';
                this.pdfContent.style.marginTop = '0';
                this.pdfContent.style.marginBottom = '0';
                
                console.log('강제 중앙 정렬 완료:', {
                    wrapperSize: { width: wrapperWidth, height: wrapperHeight },
                    alignItems: this.pdfWrapper.style.alignItems,
                    paddingTop: this.pdfWrapper.style.paddingTop
                });
            }

            updateImageSize() {
                if (!this.pdfImage.src || !this.originalPageWidth || !this.originalPageHeight) return;
                
                // 원본 크기 기준으로 스케일된 크기 계산
                const scaledWidth = this.originalPageWidth * this.scale;
                const scaledHeight = this.originalPageHeight * this.scale;
                
                // 이미지 크기 업데이트 (transform 제거하고 실제 크기로)
                this.pdfImage.style.transform = '';
                this.pdfImage.style.transformOrigin = '';
                this.pdfImage.style.width = scaledWidth + 'px';
                this.pdfImage.style.height = scaledHeight + 'px';
                
                // 텍스트 레이어 크기 업데이트
                this.textLayer.style.transform = '';
                this.textLayer.style.transformOrigin = '';
                this.textLayer.style.width = scaledWidth + 'px';
                this.textLayer.style.height = scaledHeight + 'px';
            }
            
            updateScrollAreaForZoom() {
                console.log('=== UPDATE SCROLL AREA FOR ZOOM 시작 ===');
                if (!this.pdfImage.src || !this.originalPageWidth || !this.originalPageHeight) {
                    console.log('PDF 이미지나 원본 크기 정보가 없음');
                    return;
                }

                // 강제로 컨테이너 크기 재계산
                const containerRect = this.pdfContainer.getBoundingClientRect();
                console.log('컨테이너 rect:', containerRect);
                
                const scaledWidth = this.originalPageWidth * this.scale;
                const scaledHeight = this.originalPageHeight * this.scale;
                const margin = 40;
                
                console.log('스케일된 크기:', { scaledWidth, scaledHeight, margin });
                console.log('현재 fitMode:', this.fitMode);
                
                const containerWidth = containerRect.width;
                const containerHeight = containerRect.height;
                
                // 페이지 맞춤 모드
                if (this.fitMode === 'page') {
                    console.log('페이지 맞춤 모드 레이아웃 설정');
                    this.pdfWrapper.style.width = scaledWidth + 'px';
                    this.pdfWrapper.style.height = scaledHeight + 'px';
                    this.pdfWrapper.style.justifyContent = 'center';
                    this.pdfWrapper.style.alignItems = 'center';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.padding = '0';
                    this.pdfWrapper.style.margin = '0 auto';
                    this.pdfWrapper.style.minWidth = 'unset';
                    this.pdfWrapper.style.minHeight = 'unset';
                    this.pdfWrapper.style.boxSizing = 'content-box';
                    
                    console.log('페이지 맞춤 wrapper 설정 완료:', {
                        width: this.pdfWrapper.style.width,
                        height: this.pdfWrapper.style.height,
                        justifyContent: this.pdfWrapper.style.justifyContent,
                        alignItems: this.pdfWrapper.style.alignItems
                    });
                    
                } else if (this.fitMode === 'width') {
                    console.log('너비 맞춤 모드 레이아웃 설정');
                    this.pdfWrapper.style.boxSizing = 'content-box';
                    this.pdfWrapper.style.width = '100%'; // containerWidth 대신 100% 사용
                    this.pdfWrapper.style.height = 'auto'; // 고정 높이 대신 auto
                    this.pdfWrapper.style.minHeight = Math.max(scaledHeight + margin, containerHeight) + 'px';
                    this.pdfWrapper.style.justifyContent = 'center';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.padding = `${margin/2}px 0`;
                    this.pdfWrapper.style.alignItems = 'flex-start'; // **항상 상단 정렬**
                    
                    // **PDF 콘텐츠 margin 초기화**
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.pdfContent.style.marginBottom = '0';
                    
                    console.log('너비 맞춤 wrapper 설정 완료:', {
                        width: this.pdfWrapper.style.width,
                        height: this.pdfWrapper.style.height,
                        minHeight: this.pdfWrapper.style.minHeight
                    });
                    
                } else {
                    console.log('기본 모드 레이아웃 설정');
                    // 기본 모드
                    const wrapperWidth = Math.max(scaledWidth + margin, containerWidth);
                    const wrapperHeight = Math.max(scaledHeight + margin, containerHeight);
                    
                    this.pdfWrapper.style.width = wrapperWidth + 'px';
                    this.pdfWrapper.style.height = wrapperHeight + 'px';
                    this.pdfWrapper.style.display = 'flex';
                    this.pdfWrapper.style.justifyContent = 'center';
                    
                    console.log('기본 모드 wrapper 크기:', { wrapperWidth, wrapperHeight });
                    
                    // **핵심 수정: 작은 스케일이거나 이미 중앙 정렬이 설정된 경우 유지**
                    const currentAlignment = this.pdfWrapper.style.alignItems;
                    const shouldForceCenterAlign = currentAlignment === 'center' || this.scale < 2.5;
                    
                    if (shouldForceCenterAlign) {
                        this.pdfWrapper.style.alignItems = 'center';
                        this.pdfWrapper.style.paddingTop = '0px';
                        console.log('기본 모드 - 중앙 정렬 (강제 또는 작은 크기)');
                    } else if (scaledHeight > containerHeight && scaledWidth <= containerWidth) {
                        this.pdfWrapper.style.alignItems = 'flex-start';
                        this.pdfWrapper.style.paddingTop = `${margin/2}px`;
                        this.pdfWrapper.style.boxSizing = 'border-box';
                        console.log('기본 모드 - 세로만 스크롤, 위쪽 정렬');
                    } else {
                        this.pdfWrapper.style.alignItems = 'flex-start';
                        this.pdfWrapper.style.paddingTop = `${margin/2}px`;
                        this.pdfWrapper.style.boxSizing = 'border-box';
                        console.log('기본 모드 - 가로/세로 모두 스크롤, 위쪽 정렬');
                    }
                    
                    console.log('기본 모드 wrapper 설정 완료:', {
                        alignItems: this.pdfWrapper.style.alignItems,
                        paddingTop: this.pdfWrapper.style.paddingTop
                    });
                }
                
                // pdfContent margin 확인
                const contentStyle = getComputedStyle(this.pdfContent);
                console.log('pdfContent 현재 margin:', {
                    margin: contentStyle.margin,
                    marginTop: contentStyle.marginTop,
                    marginBottom: contentStyle.marginBottom
                });
                
                console.log('=== UPDATE SCROLL AREA FOR ZOOM 완료 ===');
            }
            
            getCurrentPageViewport() {
                // 저장된 원본 크기 사용 (가장 정확함)
                if (this.originalPageWidth && this.originalPageHeight) {
                    return { 
                        width: this.originalPageWidth, 
                        height: this.originalPageHeight 
                    };
                }
                
                // 마지막 수단: 기본값 반환
                return { width: 800, height: 600 };
            }
            
            scheduleTextLayerUpdate() {
                // 기존 타이머 취소
                if (this.textLayerTimeout) {
                    clearTimeout(this.textLayerTimeout);
                }
                
                // 100ms 후에 텍스트 레이어만 업데이트
                this.textLayerTimeout = setTimeout(async () => {
                    if (this.pdf) {
                        const page = await this.pdf.getPage(this.currentPage);
                        const displayViewport = page.getViewport({scale: this.scale});
                        await this.renderTextLayer(page, displayViewport);
                    }
                }, 100);
            }

            updateUI() {
                this.pageInput.value = this.currentPage;
                this.pageInput.max = this.totalPages;
                this.totalPagesSpan.textContent = this.totalPages;
                
                // 페이지 입력 박스 크기 동적 조정
                this.updatePageInputWidth();
                
                const zoomPercent = Math.round(this.scale * 100);
                this.updateZoomSelect(zoomPercent);
                
                // 배율 선택 박스 크기 동적 조정
                this.updateZoomSelectWidth();
                
                // 확대/축소 버튼 상태 업데이트
                this.updateZoomButtonStates();
                
                this.updateFitToggle();
                
                // 썸네일 버튼 상태 업데이트
                this.updateThumbnailButtonState();
            }
            
            // 썸네일 버튼 상태 업데이트
            updateThumbnailButtonState() {
                if (this.isThumbnailWindowOpen) {
                    // 썸네일 창이 열려있는 상태
                    this.thumbnailsBtn.textContent = '🪟';
                    this.thumbnailsBtn.title = '축소판 창 (열림) - Ctrl+Q로 닫기';
                } else {
                    // 썸네일 창이 닫혀있는 상태 - 사이드바 상태와 관계없이 기본 아이콘으로
                    this.thumbnailsBtn.textContent = '🖼️';
                    if (this.isThumbnailsOpen) {
                        this.thumbnailsBtn.title = '축소판 창 열기 (Ctrl+Q)';
                    } else {
                        this.thumbnailsBtn.title = '페이지 썸네일';
                    }
                }
            }
            
            updateZoomButtonStates() {
                // 최소/최대 스케일 체크
                const minScale = 0.25;
                const maxScale = 5.0;
                
                // 축소 버튼 상태
                if (this.scale <= minScale) {
                    this.zoomOut.classList.add('disabled');
                    this.zoomOut.title = '최소 배율입니다';
                } else {
                    this.zoomOut.classList.remove('disabled');
                    this.zoomOut.title = '축소 (Ctrl+-)';
                }
                
                // 확대 버튼 상태
                if (this.scale >= maxScale) {
                    this.zoomIn.classList.add('disabled');
                    this.zoomIn.title = '최대 배율입니다';
                } else {
                    this.zoomIn.classList.remove('disabled');
                    this.zoomIn.title = '확대 (Ctrl++)';
                }
            }
            
            updatePageInputWidth() {
                // 전체 페이지 수의 자릿수 계산
                const digits = this.totalPages.toString().length;
                
                // 모바일 여부 체크
                const isMobile = window.innerWidth <= 768;
                
                if (isMobile) {
                    // 모바일: 더 작은 크기
                    const baseWidth = 12;
                    const charWidth = 7;
                    const calculatedWidth = baseWidth + (digits * charWidth);
                    const minWidth = 30;
                    const maxWidth = 60;
                    const finalWidth = Math.max(minWidth, Math.min(maxWidth, calculatedWidth));
                    this.pageInput.style.width = finalWidth + 'px';
                } else {
                    // 데스크톱: 기본 크기
                    const baseWidth = 16;
                    const charWidth = 8;
                    const calculatedWidth = baseWidth + (digits * charWidth);
                    const minWidth = 35;
                    const maxWidth = 80;
                    const finalWidth = Math.max(minWidth, Math.min(maxWidth, calculatedWidth));
                    this.pageInput.style.width = finalWidth + 'px';
                }
            }
            
            updateZoomSelectWidth() {
                // 모바일 여부 체크
                const isMobile = window.innerWidth <= 768;
                
                if (isMobile) {
                    // 모바일: 더 작은 크기
                    const baseWidth = 12;
                    const textWidth = 20;
                    const percentWidth = 7;
                    const arrowWidth = 10;
                    const finalWidth = baseWidth + textWidth + percentWidth + arrowWidth;
                    this.zoomSelect.style.minWidth = finalWidth + 'px';
                    this.zoomSelect.style.width = finalWidth + 'px';
                } else {
                    // 데스크톱: 기본 크기
                    const baseWidth = 16;
                    const textWidth = 24;
                    const percentWidth = 8;
                    const arrowWidth = 12;
                    const finalWidth = baseWidth + textWidth + percentWidth + arrowWidth;
                    this.zoomSelect.style.minWidth = finalWidth + 'px';
                    this.zoomSelect.style.width = finalWidth + 'px';
                }
            }

            updateZoomSelect(currentZoom) {
                const defaultOptions = [25, 50, 75, 100, 125, 150, 200, 300, 400, 500];
                
                let allOptions = [...defaultOptions];
                if (!allOptions.includes(currentZoom)) {
                    allOptions.push(currentZoom);
                    allOptions.sort((a, b) => a - b);
                }
                
                this.zoomSelect.innerHTML = '';
                allOptions.forEach(zoom => {
                    const option = document.createElement('option');
                    option.value = zoom;
                    option.textContent = zoom + '%';
                    if (zoom === currentZoom) {
                        option.selected = true;
                    }
                    this.zoomSelect.appendChild(option);
                });
            }
            
            async previousPage() {
                if (this.currentPage <= 1) return;
                
                console.log('=== PREVIOUS PAGE 시작 ===');
                console.log('현재 페이지:', this.currentPage, '→', this.currentPage - 1);
                
                // 페이지 이동 중 플래그 설정
                this.isPageTransitioning = true;
                
                try {
                    this.currentPage--;
                    
                    // 1. 렌더링 전에 새 페이지에 맞는 스케일을 먼저 계산
                    if (this.fitMode !== 'none') {
                        const page = await this.pdf.getPage(this.currentPage);
                        if (this.fitMode === 'width') {
                            await this.calculateFitToWidth(page);
                        } else if (this.fitMode === 'page') {
                            await this.calculateFitToPage(page);
                        }
                    }

                    // 2. 페이지 렌더링 완료까지 대기
                    await this.renderPage();

                    // 3. UI 업데이트
                    this.updateUI();
                    this.updateThumbnailSelection();
                    this.updateThumbnailWindowSelection();

                    // 4. 스크롤 위치를 확실하게 고정
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.forceScrollToTopForPageTransition();

                    // 5. 자동 복사 기능 실행
                    await this.performAutoTrack();
                    
                } catch (error) {
                    console.error('이전 페이지 이동 실패:', error);
                    this.showToastMessage('❌ 이전 페이지로 이동할 수 없습니다');
                    // 실패 시 페이지 번호 복원
                    this.currentPage++;
                    this.updateUI();
                } finally {
                    // 페이지 이동 완료 후 플래그 해제
                    setTimeout(() => {
                        this.isPageTransitioning = false;
                        console.log('페이지 이동 완료, maintainPDFCenter 재활성화');
                    }, 300);
                }
            }

            async nextPage() {
                if (this.currentPage >= this.totalPages) return;
                        
                console.log('=== NEXT PAGE 시작 ===');
                console.log('현재 페이지:', this.currentPage, '→', this.currentPage + 1);
                console.log('현재 스케일:', this.scale);
                console.log('현재 fitMode:', this.fitMode);
                
                // 페이지 이동 중 플래그 설정
                this.isPageTransitioning = true;
                
                const container = this.pdfContainer;
                console.log('이동 전 스크롤 위치:', {
                    scrollTop: container.scrollTop,
                    scrollLeft: container.scrollLeft,
                    scrollHeight: container.scrollHeight,
                    clientHeight: container.clientHeight
                });
                
                try {
                    this.currentPage++;
                    
                    // 1. 렌더링 전에 새 페이지에 맞는 스케일을 먼저 계산
                    if (this.fitMode !== 'none') {
                        console.log('맞춤 모드 스케일 계산 중...');
                        const page = await this.pdf.getPage(this.currentPage);
                        const oldScale = this.scale;
                        
                        if (this.fitMode === 'width') {
                            await this.calculateFitToWidth(page);
                        } else if (this.fitMode === 'page') {
                            await this.calculateFitToPage(page);
                        }
                        
                        console.log('스케일 변경:', oldScale, '→', this.scale);
                    }

                    // 2. 페이지 렌더링 완료까지 대기
                    console.log('페이지 렌더링 시작...');
                    await this.renderPage();
                    console.log('페이지 렌더링 완료');

                    // 3. UI 업데이트
                    this.updateUI();
                    this.updateThumbnailSelection();
                    this.updateThumbnailWindowSelection();

                    // 4. 스크롤 위치를 확실하게 고정
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.forceScrollToTopForPageTransition();
                    
                    console.log('강제 스크롤 설정 완료:', container.scrollTop);

                    // 5. 자동 복사 기능 실행
                    await this.performAutoTrack();
                    
                } catch (error) {
                    console.error('다음 페이지 이동 실패:', error);
                    this.showToastMessage('❌ 다음 페이지로 이동할 수 없습니다');
                    this.currentPage--;
                    this.updateUI();
                } finally {
                    // 페이지 이동 완료 후 플래그 해제 (타이밍 최적화)
                    setTimeout(() => {
                        this.isPageTransitioning = false;
                        console.log('페이지 이동 완료, maintainPDFCenter 재활성화');
                    }, 300);
                }
            }

            async goToPage() {
                const pageNum = parseInt(this.pageInput.value);
                
                // 입력값 검증
                if (isNaN(pageNum) || pageNum < 1 || pageNum > this.totalPages) {
                    this.pageInput.value = this.currentPage;
                    this.showToastMessage('❌ 올바른 페이지 번호를 입력해주세요');
                    return;
                }
                
                // 같은 페이지면 무시
                if (pageNum === this.currentPage) {
                    return;
                }
                
                console.log('=== GO TO PAGE 시작 ===');
                console.log('현재 페이지:', this.currentPage, '→', pageNum);
                
                // 페이지 이동 중 플래그 설정
                this.isPageTransitioning = true;
                
                try {
                    const previousPage = this.currentPage;
                    this.currentPage = pageNum;

                    // 1. 렌더링 전에 새 페이지에 맞는 스케일 계산
                    if (this.fitMode !== 'none') {
                        const page = await this.pdf.getPage(this.currentPage);
                        if (this.fitMode === 'width') {
                            await this.calculateFitToWidth(page);
                        } else if (this.fitMode === 'page') {
                            await this.calculateFitToPage(page);
                        }
                    }

                    // 2. 페이지 렌더링 완료까지 대기
                    await this.renderPage();

                    // 3. UI 업데이트
                    this.updateUI();
                    this.updateThumbnailSelection();
                    this.updateThumbnailWindowSelection();
                    
                    // 4. 스크롤 위치를 확실하게 고정
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.forceScrollToTopForPageTransition();

                    // 5. 자동 복사 기능 실행
                    await this.performAutoTrack();
                    
                } catch (error) {
                    console.error('페이지 이동 실패:', error);
                    this.showToastMessage(`❌ ${pageNum}페이지로 이동할 수 없습니다`);
                    // 실패 시 이전 페이지로 복원
                    this.currentPage = previousPage;
                    this.pageInput.value = this.currentPage;
                    this.updateUI();
                } finally {
                    // 페이지 이동 완료 후 플래그 해제
                    setTimeout(() => {
                        this.isPageTransitioning = false;
                        console.log('페이지 이동 완료, maintainPDFCenter 재활성화');
                    }, 300);
                }
            }

            scrollToTop() {
                const container = this.pdfContainer;
                
                // 스크롤 영역 재계산 후 맨 위로
                container.offsetHeight;
                
                container.scrollTo({
                    top: 0,
                    left: container.scrollLeft,
                    behavior: 'smooth'
                });
            }

            scrollToBottom() {
                // 부드러운 스크롤로 맨 아래로 이동
                this.pdfContainer.scrollTo({
                    top: this.pdfContainer.scrollHeight,
                    left: this.pdfContainer.scrollLeft, // 가로 스크롤은 유지
                    behavior: 'smooth'
                });
            }
            
            // scrollToBottom 함수 다음에 추가
            forceScrollToTop() {
                const container = this.pdfContainer;
                
                // 즉시 스크롤을 0으로 설정
                container.scrollTop = 0;
                container.scrollLeft = Math.max(0, container.scrollLeft); // 가로 스크롤은 유지
                
                // 레이아웃 강제 업데이트
                requestAnimationFrame(() => {
                    container.scrollTop = 0;
                    
                    // 한 번 더 확인
                    setTimeout(() => {
                        if (container.scrollTop !== 0) {
                            container.scrollTop = 0;
                        }
                    }, 50);
                });
            }
            
            // 페이지 이동 전용 강력한 스크롤 고정 함수
            forceScrollToTopForPageTransition() {
                const container = this.pdfContainer;
                const wrapper = this.pdfWrapper;
                
                // 1차: 즉시 설정
                container.scrollTop = 0;
                
                // **중요 변경: alignItems는 건드리지 않음 - 중앙 정렬 유지**
                wrapper.style.justifyContent = 'center';
                // wrapper.style.alignItems = 'flex-start'; // 이 줄 제거!
                
                // 2차: 레이아웃 강제 업데이트 후 재설정
                container.offsetHeight; // 강제 리플로우
                container.scrollTop = 0;
                
                // 3차: 다음 프레임에서 재확인
                requestAnimationFrame(() => {
                    container.scrollTop = 0;
                    // wrapper.style.alignItems = 'flex-start'; // 이 줄도 제거!
                    
                    // 4차: 추가 안정화
                    setTimeout(() => {
                        if (this.isPageTransitioning) {
                            container.scrollTop = 0;
                            // alignItems는 건드리지 않음
                        }
                    }, 50);
                });
                
                // 페이지 이동 중임을 명시적으로 표시
                container.setAttribute('data-page-transitioning', 'true');
                wrapper.setAttribute('data-page-transitioning', 'true');
                
                // **차단 시간을 대폭 단축 (200ms)**
                setTimeout(() => {
                    container.removeAttribute('data-page-transitioning');
                    wrapper.removeAttribute('data-page-transitioning');
                }, 200); // 500ms에서 200ms로 대폭 단축
                
                console.log('페이지 이동용 스크롤 고정 완료 - scrollTop:', container.scrollTop);
            }

            // 텍스트가 선택되어 있는지 확인
            hasTextSelection() {
                const selection = window.getSelection();
                return selection && selection.toString().trim().length > 0;
            }

            // 선택된 텍스트를 클립보드에 복사
            async copySelectedText() {
                const selection = window.getSelection();
                const selectedText = selection.toString();
                
                if (selectedText.trim().length > 0) {
                    try {
                        await navigator.clipboard.writeText(selectedText);
                        this.showToastMessage('✅ 텍스트가 클립보드에 복사되었습니다!');
                        return true;
                    } catch (err) {
                        console.error('텍스트 복사 실패:', err);
                        return false;
                    }
                }
                return false;
            }

            // 이미지를 클립보드에 복사 - 현재 표시된 이미지 사용
            async copyImageToClipboard() {
                if (!this.pdf) return false;

                try {
                    // 현재 페이지 가져오기
                    const page = await this.pdf.getPage(this.currentPage);
                    
                    // 고정된 고품질 배율로 렌더링
                    const fixedScale = this.renderScale; // 3.0 사용
                    const viewport = page.getViewport({scale: fixedScale});
                    
                    // 임시 Canvas 생성 (클립보드 복사용)
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    
                    // 임시 캔버스에 렌더링
                    const renderContext = {
                        canvasContext: tempCtx,
                        viewport: viewport
                    };
                    
                    // 별도 렌더링 작업으로 실행
                    const tempRenderTask = page.render(renderContext);
                    await tempRenderTask.promise;
                    
                    // Canvas를 클립보드에 복사 (모바일에서는 다운로드로 대체)
                    tempCanvas.toBlob(async (blob) => {
                        try {
                            // 클립보드 API 지원 체크
                            if (navigator.clipboard && navigator.clipboard.write && !this.isMobile) {
                                const item = new ClipboardItem({'image/png': blob});
                                await navigator.clipboard.write([item]);
                                this.showToastMessage('✅ 이미지가 클립보드에 복사되었습니다!');
                            } else {
                                // 모바일이거나 클립보드 API 미지원 시 다운로드
                                this.downloadBlobAsImage(blob, `page_${this.currentPage}.png`);
                                this.showToastMessage('📱 모바일에서는 이미지가 다운로드됩니다!');
                            }
                        } catch (error) {
                            // 클립보드 실패 시 사용자에게 다운로드 여부 확인
                            console.log('클립보드 복사 실패:', error);
                            const shouldDownload = await this.showConfirmModal(
                                '클립보드 복사 실패',
                                '클립보드 복사에 실패했습니다.\n대신 이미지 파일로 다운로드하시겠습니까?'
                            );
                            
                            if (shouldDownload) {
                                this.downloadBlobAsImage(blob, `page_${this.currentPage}.png`);
                                this.showToastMessage('📥 이미지를 다운로드했습니다!');
                            } else {
                                this.showToastMessage('❌ 복사가 취소되었습니다');
                            }
                        }
                    }, 'image/png', 1.0);
                    
                    return true;
                } catch (err) {
                    console.error('이미지 복사 실패:', err);
                    this.showToastMessage('❌ 이미지 복사에 실패했습니다.');
                    return false;
                }
            }

            // Blob을 이미지 파일로 다운로드
            downloadBlobAsImage(blob, filename) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 메모리 정리
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 1000);
            }

            // 스마트 복사 - 텍스트 선택되어 있으면 텍스트, 아니면 이미지
            async smartCopy() {
                if (this.hasTextSelection()) {
                    return await this.copySelectedText();
                } else {
                    return await this.copyImageToClipboard();
                }
            }

            // PDF 내 모든 텍스트 선택
            selectAllPDFText() {
                const textSpans = this.textLayer.querySelectorAll('span');
                if (textSpans.length === 0) return;

                const selection = window.getSelection();
                selection.removeAllRanges();
                
                const range = document.createRange();
                range.setStartBefore(textSpans[0]);
                range.setEndAfter(textSpans[textSpans.length - 1]);
                
                selection.addRange(range);
                this.showToastMessage('📄 PDF 텍스트 전체 선택됨');
            }

            showToastMessage(message, forceShow = false) {
                // 토스트가 비활성화되어 있고 강제 표시가 아니면 표시하지 않음
                if (!this.isToastEnabled && !forceShow) {
                    return;
                }
                
                // 메시지 정규화 (공백 제거)
                const normalizedMessage = message.trim();
                
                // 메시지 패턴 분석하여 그룹화 키 생성
                const groupKey = this.getToastGroupKey(normalizedMessage);
                
                // 기존에 같은 그룹의 토스트가 있는지 확인
                if (this.activeToasts.has(groupKey)) {
                    const existingToast = this.activeToasts.get(groupKey);
                    
                    // 카운터 증가
                    existingToast.count++;
                    
                    // 토스트 내용을 최신 메시지로 업데이트
                    existingToast.element.childNodes[0].textContent = normalizedMessage;
                    
                    // 카운터 뱃지 업데이트
                    let counterBadge = existingToast.element.querySelector('.toast-counter');
                    if (!counterBadge) {
                        counterBadge = document.createElement('div');
                        counterBadge.className = 'toast-counter';
                        existingToast.element.appendChild(counterBadge);
                    }
                    counterBadge.textContent = existingToast.count;
                    
                    // 기존 타이머 취소하고 새 타이머 시작
                    if (existingToast.hideTimeout) {
                        clearTimeout(existingToast.hideTimeout);
                    }
                    if (existingToast.removeTimeout) {
                        clearTimeout(existingToast.removeTimeout);
                    }
                    
                    // 토스트를 다시 완전히 보이게 만들기
                    existingToast.element.classList.remove('hide');
                    existingToast.element.classList.add('show');
                    
                    // 새로운 타이머 설정
                    existingToast.hideTimeout = setTimeout(() => {
                        this.hideToast(groupKey);
                    }, 3000);
                    
                    return;
                }
                
                // 새로운 토스트 요소 생성
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = normalizedMessage;
                
                // 토스트 정보 저장
                const toastInfo = {
                    element: toast,
                    count: 1,
                    hideTimeout: null,
                    removeTimeout: null
                };
                
                this.activeToasts.set(groupKey, toastInfo);
                
                // 컨테이너에 추가
                this.toastContainer.appendChild(toast);
                
                // 즉시 표시 (애니메이션 트리거를 위해 약간의 딜레이)
                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);
                
                // 3초 후에 숨기기 시작
                toastInfo.hideTimeout = setTimeout(() => {
                    this.hideToast(groupKey);
                }, 3000);
            }

            hideToast(groupKey) {
                const toastInfo = this.activeToasts.get(groupKey);
                if (!toastInfo) return;
                
                const toast = toastInfo.element;
                toast.classList.add('hide');
                toast.classList.remove('show');
                
                // 애니메이션 완료 후 요소 제거
                toastInfo.removeTimeout = setTimeout(() => {
                    if (toast.parentNode) {
                        this.toastContainer.removeChild(toast);
                    }
                    this.activeToasts.delete(groupKey);
                }, 300);
            }

            getToastGroupKey(message) {
                // 페이지 선택 관련 메시지 패턴들
                const patterns = [
                    {
                        // "📋 X개 페이지 선택됨" 패턴
                        regex: /^📋 \d+개 페이지 선택됨$/,
                        key: '📋 페이지 선택됨'
                    },
                    {
                        // "📋 X-Y페이지 범위 선택 (총 Z개 선택됨)" 패턴
                        regex: /^📋 \d+-\d+페이지 범위 선택 \(총 \d+개 선택됨\)$/,
                        key: '📋 페이지 범위 선택'
                    },
                    {
                        // "📖 X페이지로 이동했습니다" 패턴
                        regex: /^📖 \d+페이지로 이동했습니다$/,
                        key: '📖 페이지 이동'
                    },
                    {
                        // "🔄 X개 페이지 복사 중..." 패턴
                        regex: /^🔄 \d+개 페이지 복사 중\.\.\.$/,
                        key: '🔄 페이지 복사 중'
                    },
                    {
                        // "✅ X개의 PDF 파일을 찾았습니다" 패턴
                        regex: /^✅ \d+개의 PDF 파일을 찾았습니다$/,
                        key: '✅ PDF 파일 찾음'
                    },
                    {
                        // "✅ X개의 PDF 파일을 추가했습니다" 패턴
                        regex: /^✅ \d+개의 PDF 파일을 추가했습니다$/,
                        key: '✅ PDF 파일 추가'
                    },
                    {
                        // "📥 X개 페이지를 다운로드했습니다!" 패턴
                        regex: /^📥 \d+개 페이지를 다운로드했습니다!$/,
                        key: '📥 페이지 다운로드'
                    },
                    {
                        // "✅ X개 페이지가 개별 이미지로 복사되었습니다!" 패턴
                        regex: /^✅ \d+개 페이지가 개별 이미지로 복사되었습니다!$/,
                        key: '✅ 페이지 개별 복사'
                    },
                    {
                        // "✅ X개 페이지가 합쳐져서 복사되었습니다!" 패턴
                        regex: /^✅ \d+개 페이지가 합쳐져서 복사되었습니다!$/,
                        key: '✅ 페이지 합쳐서 복사'
                    },
                    {
                        // "📱 X개 페이지가 개별 파일로 다운로드됩니다!" 패턴
                        regex: /^📱 \d+개 페이지가 개별 파일로 다운로드됩니다!$/,
                        key: '📱 페이지 개별 다운로드'
                    }
                ];
                
                // 패턴에 매칭되는지 확인
                for (const pattern of patterns) {
                    if (pattern.regex.test(message)) {
                        return pattern.key;
                    }
                }
                
                // 패턴에 매칭되지 않으면 원본 메시지를 키로 사용 (기존 동작)
                return message;
            }
            
            // 캡쳐 모드 토글
            toggleCaptureMode() {
                this.isCaptureMode = !this.isCaptureMode;
                
                if (this.isCaptureMode) {
                    // 캡쳐 모드 활성화 시 화면이 좁은 경우에만 사이드바 닫기
                    if (this.isIconPanelOpen && this.shouldCloseSidebarForCapture()) {
                        this.toggleIconPanel();
                        this.showToastMessage('📄 캡쳐 공간 확보를 위해 사이드바를 닫았습니다');
                        // 사이드바 닫기 애니메이션 대기 후 캡쳐 모드 활성화
                        setTimeout(() => {
                            this.activateCaptureMode();
                        }, 300);
                    } else {
                        // 사이드바가 닫혀있거나 화면이 충분히 넓으면 바로 캡쳐 모드 활성화
                        this.activateCaptureMode();
                    }
                } else {
                    // 캡쳐 모드 비활성화
                    this.exitCaptureMode();
                }
            }

            // 캡쳐를 위해 사이드바를 닫아야 하는지 판단
            shouldCloseSidebarForCapture() {
                // 모바일인 경우 항상 닫기 (화면이 작으니까)
                if (this.isMobile) {
                    return true;
                }
                
                // 데스크톱에서는 사이드바를 뺀 나머지 공간이 좁으면 닫기
                const windowWidth = window.innerWidth;
                const sidebarWidth = this.isThumbnailsOpen || this.isFolderOpen ? 318 : 48; // 사이드바 실제 너비
                const availableWidth = windowWidth - sidebarWidth;
                
                // 캡쳐할 공간이 800px보다 작으면 좁다고 판단
                const minimumCaptureWidth = 400;
                
                return availableWidth < minimumCaptureWidth;
            }

            // 캡쳐 모드 활성화 (별도 함수로 분리)
            activateCaptureMode() {
                // 드롭다운이 열려있으면 닫기
                if (this.isDropdownOpen) {
                    this.hideDropdown();
                }
                
                // 썸네일 창이 열려있으면 닫기
                if (this.isThumbnailWindowOpen) {
                    this.closeThumbnailWindow();
                }
                
                this.captureBtn.classList.add('capture-mode');
                this.captureBtn.title = '캡쳐 모드 종료 (ESC)';
                this.captureOverlay.classList.add('active');
                this.captureGuide.classList.add('show');
                
                // 텍스트 선택 비활성화
                this.textLayer.style.pointerEvents = 'none';
                
                // 모바일에서 캡쳐 가이드 메시지 변경
                if (this.isMobile) {
                    this.captureGuide.textContent = '터치하여 캡쳐할 영역을 선택하세요 (ESC: 종료)';
                    this.showToastMessage('✂️ 캡쳐 모드 활성화! 터치로 영역을 선택하면 이미지가 다운로드됩니다');
                } else {
                    this.captureGuide.textContent = '드래그하여 캡쳐할 영역을 선택하세요 (ESC: 종료)';
                    this.showToastMessage('✂️ 캡쳐 모드 활성화! 드래그하여 영역을 선택하세요');
                }
            }
            
            exitCaptureMode() {
                this.isCaptureMode = false;
                this.isSelecting = false;
                
                // UI 복원
                this.captureBtn.classList.remove('capture-mode');
                this.captureBtn.title = '영역 캡쳐 (Ctrl+Shift+X)';
                this.captureOverlay.classList.remove('active');
                this.captureGuide.classList.remove('show');
                this.selectionArea.style.display = 'none';
                
                // 텍스트 선택 복원
                this.textLayer.style.pointerEvents = 'auto';
            }
            
            // 터치 시작 처리 (스와이프 감지용)
            handleTouchStart(e) {
                if (this.isCaptureMode) return; // 캡쳐 모드에서는 스와이프 비활성화
                
                const touch = e.touches[0];
                this.touchStartX = touch.clientX;
                this.touchStartY = touch.clientY;
                this.touchStartTime = Date.now();
                this.isTouch = true;
            }
            
            // 터치 종료 처리 (스와이프 감지)
            async handleTouchEnd(e) {
                if (!this.isTouch || this.isCaptureMode) return;
                
                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX;
                const touchEndY = touch.clientY;
                const touchEndTime = Date.now();
                
                const deltaX = touchEndX - this.touchStartX;
                const deltaY = touchEndY - this.touchStartY;
                const deltaTime = touchEndTime - this.touchStartTime;
                
                this.isTouch = false;
                
                // 스와이프 시간이 너무 길면 무시
                if (deltaTime > this.swipeTimeThreshold) return;
                
                const absDeltaX = Math.abs(deltaX);
                const absDeltaY = Math.abs(deltaY);
                
                // 좌우 스와이프 (페이지 이동)
                if (absDeltaX > this.swipeThreshold && absDeltaX > absDeltaY) {
                    if (deltaX > 0) {
                        // 우측 스와이프 - 이전 페이지
                        await this.previousPage();
                    } else {
                        // 좌측 스와이프 - 다음 페이지  
                        await this.nextPage();
                    }
                }
                // 상하 스와이프는 스크롤로 처리 (기본 동작)
            }
            
            // 좌표 추출 함수 (마우스/터치 통합)
            getEventCoordinates(e) {
                if (e.touches && e.touches.length > 0) {
                    // 터치 이벤트
                    return {
                        clientX: e.touches[0].clientX,
                        clientY: e.touches[0].clientY
                    };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    // 터치 종료 이벤트
                    return {
                        clientX: e.changedTouches[0].clientX,
                        clientY: e.changedTouches[0].clientY
                    };
                } else {
                    // 마우스 이벤트
                    return {
                        clientX: e.clientX,
                        clientY: e.clientY
                    };
                }
            }
            
            startSelection(e) {
                if (!this.isCaptureMode) return;
                
                e.preventDefault();
                this.isSelecting = true;
                
                // 터치/마우스 좌표 통합 처리
                const coords = this.getEventCoordinates(e);
                
                // 캡쳐 오버레이를 기준으로 정확한 좌표 계산
                const overlayRect = this.captureOverlay.getBoundingClientRect();
                this.selectionStart.x = coords.clientX - overlayRect.left;
                this.selectionStart.y = coords.clientY - overlayRect.top;
                this.selectionEnd.x = this.selectionStart.x;
                this.selectionEnd.y = this.selectionStart.y;
                
                this.captureGuide.classList.remove('show');
                this.selectionArea.style.display = 'block';
                this.updateSelectionArea();
            }
            
            updateSelection(e) {
                if (!this.isCaptureMode || !this.isSelecting) return;
                
                e.preventDefault();
                
                // 터치/마우스 좌표 통합 처리
                const coords = this.getEventCoordinates(e);
                
                // 캡쳐 오버레이를 기준으로 정확한 좌표 계산
                const overlayRect = this.captureOverlay.getBoundingClientRect();
                this.selectionEnd.x = coords.clientX - overlayRect.left;
                this.selectionEnd.y = coords.clientY - overlayRect.top;
                
                this.updateSelectionArea();
            }
            
            async endSelection(e) {
                if (!this.isCaptureMode || !this.isSelecting) return;
                
                e.preventDefault();
                this.isSelecting = false;
                
                const width = Math.abs(this.selectionEnd.x - this.selectionStart.x);
                const height = Math.abs(this.selectionEnd.y - this.selectionStart.y);
                
                // 최소 크기 체크 (10x10 픽셀)
                if (width < 10 || height < 10) {
                    this.showToastMessage('❌ 선택 영역이 너무 작습니다');
                    this.selectionArea.style.display = 'none';
                    this.captureGuide.classList.add('show');
                    return;
                }
                
                // 선택 영역 캡쳐
                await this.captureSelectedArea();
                this.exitCaptureMode();
            }
            
            cancelSelection(e) {
                if (!this.isCaptureMode) return;
                
                this.isSelecting = false;
                this.selectionArea.style.display = 'none';
                this.captureGuide.classList.add('show');
            }
            
            updateSelectionArea() {
                const left = Math.min(this.selectionStart.x, this.selectionEnd.x);
                const top = Math.min(this.selectionStart.y, this.selectionEnd.y);
                const width = Math.abs(this.selectionEnd.x - this.selectionStart.x);
                const height = Math.abs(this.selectionEnd.y - this.selectionStart.y);
                
                this.selectionArea.style.left = left + 'px';
                this.selectionArea.style.top = top + 'px';
                this.selectionArea.style.width = width + 'px';
                this.selectionArea.style.height = height + 'px';
            }
            
            async captureSelectedArea() {
                try {
                    if (!this.pdf) return;
                    
                    // 선택 영역 좌표 (오버레이 기준)
                    const selectLeft = Math.min(this.selectionStart.x, this.selectionEnd.x);
                    const selectTop = Math.min(this.selectionStart.y, this.selectionEnd.y);
                    const selectWidth = Math.abs(this.selectionEnd.x - this.selectionStart.x);
                    const selectHeight = Math.abs(this.selectionEnd.y - this.selectionStart.y);
                    
                    // 실제 DOM 요소들의 위치 가져오기
                    const overlayRect = this.captureOverlay.getBoundingClientRect();
                    const imageRect = this.pdfImage.getBoundingClientRect();
                    
                    // 오버레이에서 이미지로의 좌표 변환
                    const imageOffsetX = imageRect.left - overlayRect.left;
                    const imageOffsetY = imageRect.top - overlayRect.top;
                    
                    // 선택 영역을 이미지 좌표로 변환
                    const imageLeft = selectLeft - imageOffsetX;
                    const imageTop = selectTop - imageOffsetY;
                    
                    // 이미지 범위 내로 클리핑
                    const cropLeft = Math.max(0, imageLeft);
                    const cropTop = Math.max(0, imageTop);
                    const cropRight = Math.min(imageRect.width, imageLeft + selectWidth);
                    const cropBottom = Math.min(imageRect.height, imageTop + selectHeight);
                    
                    const cropWidth = cropRight - cropLeft;
                    const cropHeight = cropBottom - cropTop;
                    
                    // 유효한 영역인지 확인
                    if (cropWidth <= 5 || cropHeight <= 5) {
                        this.showToastMessage('❌ 선택 영역이 PDF 범위 내에 없거나 너무 작습니다');
                        return;
                    }
                    
                    // 현재 페이지를 고품질로 렌더링
                    const page = await this.pdf.getPage(this.currentPage);
                    const highQualityScale = this.renderScale; // 3.0
                    const viewport = page.getViewport({scale: highQualityScale});
                    
                    // 임시 캔버스 생성 및 렌더링
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    tempCanvas.width = viewport.width;
                    tempCanvas.height = viewport.height;
                    
                    const renderContext = {
                        canvasContext: tempCtx,
                        viewport: viewport
                    };
                    
                    const renderTask = page.render(renderContext);
                    await renderTask.promise;
                    
                    // 실제 표시된 이미지 크기와 렌더링된 캔버스 크기의 비율 계산
                    const scaleRatio = viewport.width / imageRect.width;
                    
                    // 캔버스에서 잘라낼 영역 계산
                    const canvasCropX = cropLeft * scaleRatio;
                    const canvasCropY = cropTop * scaleRatio;
                    const canvasCropWidth = cropWidth * scaleRatio;
                    const canvasCropHeight = cropHeight * scaleRatio;
                    
                    // 최종 캔버스 생성
                    const finalCanvas = document.createElement('canvas');
                    const finalCtx = finalCanvas.getContext('2d');
                    
                    finalCanvas.width = canvasCropWidth;
                    finalCanvas.height = canvasCropHeight;
                    
                    // 선택 영역만 복사
                    finalCtx.drawImage(
                        tempCanvas,
                        canvasCropX, canvasCropY, canvasCropWidth, canvasCropHeight,
                        0, 0, canvasCropWidth, canvasCropHeight
                    );
                    
                    // 클립보드 복사 시도 (모바일에서는 다운로드로 대체)
                    finalCanvas.toBlob(async (blob) => {
                        try {
                            // 클립보드 API 지원 체크
                            if (navigator.clipboard && navigator.clipboard.write && !this.isMobile) {
                                const item = new ClipboardItem({'image/png': blob});
                                await navigator.clipboard.write([item]);
                                this.showToastMessage('✂️ 선택 영역이 클립보드에 복사되었습니다!');
                            } else {
                                // 모바일이거나 클립보드 API 미지원 시 다운로드
                                this.downloadBlobAsImage(blob, 'captured_area.png');
                                this.showToastMessage('📱 모바일에서는 이미지가 다운로드됩니다!');
                            }
                        } catch (error) {
                            // 클립보드 실패 시 사용자에게 다운로드 여부 확인
                            console.log('클립보드 복사 실패:', error);
                            const shouldDownload = await this.showConfirmModal(
                                '클립보드 복사 실패',
                                '클립보드 복사에 실패했습니다.\n\n대신 캡쳐한 영역을 이미지 파일로 다운로드하시겠습니까?'
                            );
                            
                            if (shouldDownload) {
                                this.downloadBlobAsImage(blob, 'captured_area.png');
                                this.showToastMessage('📥 캡쳐 이미지를 다운로드했습니다!');
                            } else {
                                this.showToastMessage('❌ 캡쳐가 취소되었습니다');
                            }
                        }
                    }, 'image/png', 1.0);
                    
                } catch (error) {
                    console.error('영역 캡쳐 실패:', error);
                    this.showToastMessage('❌ 영역 캡쳐에 실패했습니다');
                }
            }
            
            async generateThumbnails() {
                if (!this.pdf) return;
                
                this.loadingThumbnails.textContent = '썸네일 생성 중...';
                this.thumbnails = [];
                this.thumbnailsContainer.innerHTML = '<div class="loading-thumbnails">썸네일 생성 중...</div>';
                
                try {
                    // 썸네일을 순차적으로 생성
                    for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                        await this.createThumbnail(pageNum);
                    }
                    
                    // 로딩 메시지 제거
                    const loadingDiv = this.thumbnailsContainer.querySelector('.loading-thumbnails');
                    if (loadingDiv) {
                        loadingDiv.remove();
                    }
                    
                    // 현재 페이지 활성화
                    this.updateThumbnailSelection();
                    
                } catch (error) {
                    console.error('썸네일 생성 실패:', error);
                    this.loadingThumbnails.textContent = '썸네일 생성 실패';
                }
            }
            
            async createThumbnail(pageNum) {
                try {
                    const page = await this.pdf.getPage(pageNum);
                    const scale = 0.6; // 썸네일 크기
                    const viewport = page.getViewport({scale: scale});
                    
                    // 썸네일 캔버스 생성
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    
                    // 썸네일 렌더링
                    const renderContext = {
                        canvasContext: ctx,
                        viewport: viewport
                    };
                    
                    const renderTask = page.render(renderContext);
                    await renderTask.promise;
                    
                    // 썸네일 아이템 생성
                    const thumbnailItem = document.createElement('div');
                    thumbnailItem.className = 'thumbnail-item';
                    thumbnailItem.dataset.page = pageNum;
                    
                    // 캔버스 추가
                    canvas.className = 'thumbnail-canvas';
                    thumbnailItem.appendChild(canvas);
                    
                    // 페이지 라벨 추가
                    const label = document.createElement('div');
                    label.className = 'thumbnail-label';
                    label.textContent = pageNum;
                    thumbnailItem.appendChild(label);
                    
                    // 클릭 이벤트
                    thumbnailItem.addEventListener('click', () => {
                        this.goToPageFromThumbnail(pageNum);
                        // 모바일에서는 썸네일 클릭 후 사이드바 닫기
                        if (this.isMobile && this.isIconPanelOpen) {
                            this.toggleIconPanel();
                        }
                    });
                    
                    // 컨테이너에 추가
                    this.thumbnailsContainer.appendChild(thumbnailItem);
                    this.thumbnails[pageNum - 1] = thumbnailItem;
                    
                } catch (error) {
                    console.error(`페이지 ${pageNum} 썸네일 생성 실패:`, error);
                }
            }
            
            async goToPageFromThumbnail(pageNum) {
                if (pageNum < 1 || pageNum > this.totalPages || pageNum === this.currentPage) {
                    return;
                }
                
                console.log('=== THUMBNAIL PAGE 시작 ===');
                console.log('현재 페이지:', this.currentPage, '→', pageNum);
                
                // 페이지 이동 중 플래그 설정
                this.isPageTransitioning = true;
                
                try {
                    this.currentPage = pageNum;

                    // 1. 렌더링 전에 새 페이지에 맞는 스케일 계산
                    if (this.fitMode !== 'none') {
                        const page = await this.pdf.getPage(this.currentPage);
                        if (this.fitMode === 'width') {
                            await this.calculateFitToWidth(page);
                        } else if (this.fitMode === 'page') {
                            await this.calculateFitToPage(page);
                        }
                    }
                    
                    // 2. 페이지 렌더링 완료까지 대기
                    await this.renderPage();
                    
                    // 3. UI 업데이트
                    this.updateUI();
                    this.updateThumbnailSelection();
                    this.updateThumbnailWindowSelection();

                    // 4. 스크롤 위치를 확실하게 고정
                    this.pdfContent.style.margin = '0';
                    this.pdfContent.style.marginTop = '0';
                    this.forceScrollToTopForPageTransition();

                    // 5. 자동 복사 기능 실행
                    await this.performAutoTrack();
                    
                } catch (error) {
                    console.error('썸네일에서 페이지 이동 실패:', error);
                    this.showToastMessage('❌ 페이지 이동에 실패했습니다');
                } finally {
                    // 페이지 이동 완료 후 플래그 해제
                    setTimeout(() => {
                        this.isPageTransitioning = false;
                        console.log('페이지 이동 완료, maintainPDFCenter 재활성화');
                    }, 300);
                }
            }

            updateThumbnailSelection() {
                // 썸네일이 없으면 아무것도 하지 않음
                if (!this.thumbnails || this.thumbnails.length === 0) return;
                
                // 모든 썸네일의 active 클래스 제거
                this.thumbnails.forEach((thumbnail, index) => {
                    if (thumbnail) {
                        thumbnail.classList.remove('active');
                    }
                });
                
                // 현재 페이지 썸네일에 active 클래스 추가
                if (this.thumbnails[this.currentPage - 1]) {
                    this.thumbnails[this.currentPage - 1].classList.add('active');
                    
                    // 현재 썸네일이 보이도록 스크롤 (썸네일 섹션이 열려있을 때만)
                    if (this.isThumbnailsOpen) {
                        this.thumbnails[this.currentPage - 1].scrollIntoView({
                            behavior: 'smooth',
                            block: 'nearest'
                        });
                    }
                }
            }

            // 선택된 페이지들을 클립보드에 개별 이미지로 복사
            async copySelectedPages() {
                if (!this.pdf || this.selectedPages.size === 0) {
                    this.showToastMessage('❌ 선택된 페이지가 없습니다');
                    return;
                }

                try {
                    // 선택된 페이지들을 정렬
                    const sortedPages = Array.from(this.selectedPages).sort((a, b) => a - b);
                    
                    this.showToastMessage(`🔄 ${sortedPages.length}개 페이지 복사 중...`);
                    
                    // 모든 페이지를 개별 이미지로 렌더링
                    const imageBlobs = [];
                    for (const pageNum of sortedPages) {
                        const page = await this.pdf.getPage(pageNum);
                        const blob = await this.renderPageToBlob(page);
                        imageBlobs.push(blob);
                    }
                    
                    // 클립보드에 여러 이미지로 복사 시도
                    if (navigator.clipboard && navigator.clipboard.write && !this.isMobile) {
                        try {
                            // 각 이미지를 ClipboardItem으로 변환
                            const clipboardItems = imageBlobs.map(blob => 
                                new ClipboardItem({'image/png': blob})
                            );
                            
                            // 여러 이미지를 클립보드에 복사
                            await navigator.clipboard.write(clipboardItems);
                            this.showToastMessage(`✅ ${sortedPages.length}개 페이지가 개별 이미지로 복사되었습니다!`);
                            return;
                        } catch (clipboardError) {
                            console.log('개별 이미지 복사 실패, 합쳐진 이미지로 시도:', clipboardError);
                            
                            // 개별 복사 실패 시 합쳐진 이미지로 시도
                            try {
                                const mergedBlob = await this.mergePageBlobs(imageBlobs, sortedPages);
                                const mergedItem = new ClipboardItem({'image/png': mergedBlob});
                                await navigator.clipboard.write([mergedItem]);
                                this.showToastMessage(`✅ ${sortedPages.length}개 페이지가 합쳐져서 복사되었습니다!`);
                                return;
                            } catch (mergeError) {
                                console.log('합쳐진 이미지 복사도 실패:', mergeError);
                                throw mergeError;
                            }
                        }
                    } else {
                        // 모바일이거나 클립보드 API 미지원 시 개별 다운로드
                        this.downloadMultipleImages(imageBlobs, sortedPages);
                        this.showToastMessage(`📱 ${sortedPages.length}개 페이지가 개별 파일로 다운로드됩니다!`);
                    }
                    
                } catch (error) {
                    console.error('페이지 복사 실패:', error);
                    
                    // 최종 실패 시 사용자에게 옵션 제공
                    const shouldDownload = await this.showConfirmModal(
                        '복사 실패',
                        `클립보드 복사에 실패했습니다.\n\n선택된 ${this.selectedPages.size}개 페이지를 개별 이미지 파일로 다운로드하시겠습니까?`
                    );
                    
                    if (shouldDownload) {
                        // 다시 렌더링해서 다운로드
                        const sortedPages = Array.from(this.selectedPages).sort((a, b) => a - b);
                        const imageBlobs = [];
                        for (const pageNum of sortedPages) {
                            const page = await this.pdf.getPage(pageNum);
                            const blob = await this.renderPageToBlob(page);
                            imageBlobs.push(blob);
                        }
                        this.downloadMultipleImages(imageBlobs, sortedPages);
                        this.showToastMessage(`📥 ${sortedPages.length}개 페이지를 다운로드했습니다!`);
                    }
                }
            }

            // 페이지를 Blob으로 렌더링
            async renderPageToBlob(page) {
                const fixedScale = this.renderScale; // 3.0 사용
                const viewport = page.getViewport({scale: fixedScale});
                
                // 임시 Canvas 생성
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                // 렌더링
                const renderContext = {
                    canvasContext: tempCtx,
                    viewport: viewport
                };
                
                const tempRenderTask = page.render(renderContext);
                await tempRenderTask.promise;
                
                // Blob으로 변환
                return new Promise((resolve) => {
                    tempCanvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 1.0);
                });
            }

            // 여러 이미지 Blob을 하나로 합치기 (fallback용)
            async mergePageBlobs(imageBlobs, pageNumbers) {
                // 모든 이미지를 Image 객체로 로드
                const images = await Promise.all(
                    imageBlobs.map(blob => {
                        return new Promise((resolve) => {
                            const img = new Image();
                            img.onload = () => resolve(img);
                            img.src = URL.createObjectURL(blob);
                        });
                    })
                );
                
                // 최대 너비와 총 높이 계산
                let maxWidth = 0;
                let totalHeight = 0;
                const pageGap = 20;
                
                images.forEach(img => {
                    maxWidth = Math.max(maxWidth, img.width);
                    totalHeight += img.height;
                });
                totalHeight += (images.length - 1) * pageGap;
                
                // 합성 캔버스 생성
                const finalCanvas = document.createElement('canvas');
                const finalCtx = finalCanvas.getContext('2d');
                
                finalCanvas.width = maxWidth;
                finalCanvas.height = totalHeight;
                
                // 배경을 흰색으로 설정
                finalCtx.fillStyle = '#ffffff';
                finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                
                // 모든 이미지를 세로로 합성
                let currentY = 0;
                images.forEach((img, index) => {
                    const x = (maxWidth - img.width) / 2;
                    finalCtx.drawImage(img, x, currentY);
                    
                    // 페이지 번호 표시
                    if (images.length > 1) {
                        finalCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        finalCtx.fillRect(x + 10, currentY + 10, 60, 30);
                        finalCtx.fillStyle = '#ffffff';
                        finalCtx.font = '16px Arial';
                        finalCtx.fillText(`${pageNumbers[index]}`, x + 20, currentY + 30);
                    }
                    
                    currentY += img.height + pageGap;
                    
                    // 메모리 정리
                    URL.revokeObjectURL(img.src);
                });
                
                // Blob으로 변환
                return new Promise((resolve) => {
                    finalCanvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png', 1.0);
                });
            }

            // 여러 이미지를 개별 파일로 다운로드
            downloadMultipleImages(imageBlobs, pageNumbers) {
                imageBlobs.forEach((blob, index) => {
                    const filename = `page_${pageNumbers[index]}.png`;
                    this.downloadBlobAsImage(blob, filename);
                });
            }

            // 단일 페이지를 클립보드에 복사
            async copyPageToClipboard(page) {
                const fixedScale = this.renderScale; // 3.0 사용
                const viewport = page.getViewport({scale: fixedScale});
                
                // 임시 Canvas 생성
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;
                
                // 렌더링
                const renderContext = {
                    canvasContext: tempCtx,
                    viewport: viewport
                };
                
                const tempRenderTask = page.render(renderContext);
                await tempRenderTask.promise;
                
                // 클립보드에 복사
                return new Promise((resolve, reject) => {
                    tempCanvas.toBlob(async (blob) => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.write && !this.isMobile) {
                                const item = new ClipboardItem({'image/png': blob});
                                await navigator.clipboard.write([item]);
                                resolve();
                            } else {
                                // 모바일이거나 클립보드 API 미지원 시 다운로드
                                this.downloadBlobAsImage(blob, `selected_pages.png`);
                                resolve();
                            }
                        } catch (error) {
                            reject(error);
                        }
                    }, 'image/png', 1.0);
                });
            }

            // 여러 페이지를 합쳐서 클립보드에 복사
            async copyMultiplePagesToClipboard(pageNumbers) {
                const fixedScale = this.renderScale; // 3.0 사용
                const pageCanvases = [];
                let totalHeight = 0;
                let maxWidth = 0;
                
                // 모든 페이지를 개별적으로 렌더링
                for (const pageNum of pageNumbers) {
                    const page = await this.pdf.getPage(pageNum);
                    const viewport = page.getViewport({scale: fixedScale});
                    
                    // 개별 페이지 캔버스 생성
                    const pageCanvas = document.createElement('canvas');
                    const pageCtx = pageCanvas.getContext('2d');
                    
                    pageCanvas.width = viewport.width;
                    pageCanvas.height = viewport.height;
                    
                    // 렌더링
                    const renderContext = {
                        canvasContext: pageCtx,
                        viewport: viewport
                    };
                    
                    const renderTask = page.render(renderContext);
                    await renderTask.promise;
                    
                    pageCanvases.push({
                        canvas: pageCanvas,
                        width: viewport.width,
                        height: viewport.height,
                        pageNum: pageNum
                    });
                    
                    totalHeight += viewport.height;
                    maxWidth = Math.max(maxWidth, viewport.width);
                }
                
                // 최종 합성 캔버스 생성
                const finalCanvas = document.createElement('canvas');
                const finalCtx = finalCanvas.getContext('2d');
                
                // 페이지 간 여백
                const pageGap = 20;
                const totalGaps = (pageCanvases.length - 1) * pageGap;
                
                finalCanvas.width = maxWidth;
                finalCanvas.height = totalHeight + totalGaps;
                
                // 배경을 흰색으로 설정
                finalCtx.fillStyle = '#ffffff';
                finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                
                // 모든 페이지를 세로로 합성
                let currentY = 0;
                pageCanvases.forEach((pageData, index) => {
                    // 페이지를 중앙 정렬하여 배치
                    const x = (maxWidth - pageData.width) / 2;
                    finalCtx.drawImage(pageData.canvas, x, currentY);
                    
                    // 페이지 번호 표시 (선택사항)
                    if (pageCanvases.length > 1) {
                        finalCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        finalCtx.fillRect(x + 10, currentY + 10, 60, 30);
                        finalCtx.fillStyle = '#ffffff';
                        finalCtx.font = '16px Arial';
                        finalCtx.fillText(`${pageData.pageNum}`, x + 20, currentY + 30);
                    }
                    
                    currentY += pageData.height + pageGap;
                });
                
                // 클립보드에 복사
                return new Promise((resolve, reject) => {
                    finalCanvas.toBlob(async (blob) => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.write && !this.isMobile) {
                                const item = new ClipboardItem({'image/png': blob});
                                await navigator.clipboard.write([item]);
                                resolve();
                            } else {
                                // 모바일이거나 클립보드 API 미지원 시 다운로드
                                const filename = `pages_${pageNumbers.join('-')}.png`;
                                this.downloadBlobAsImage(blob, filename);
                                resolve();
                            }
                        } catch (error) {
                            // 클립보드 실패 시 다운로드 옵션 제공
                            const shouldDownload = await this.showConfirmModal(
                                '클립보드 복사 실패',
                                `선택된 ${pageNumbers.length}개 페이지의 클립보드 복사에 실패했습니다.\n\n대신 이미지 파일로 다운로드하시겠습니까?`
                            );
                            
                            if (shouldDownload) {
                                const filename = `pages_${pageNumbers.join('-')}.png`;
                                this.downloadBlobAsImage(blob, filename);
                                resolve();
                            } else {
                                reject(error);
                            }
                        }
                    }, 'image/png', 1.0);
                });
            }

            handleWheel(e) {
                // 캡쳐 모드에서는 휠 이벤트 무시
                if (this.isCaptureMode) return;
                
                if (e.ctrlKey) {
                    e.preventDefault();
                    
                    // 마우스 휠 확대/축소 - 중앙 기준
                    if (!this.isZooming) {
                        this.startZooming();
                    }
                    
                    // 확대/축소 팩터 계산
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    let newScale = this.scale * zoomFactor;
                    newScale = Math.max(0.25, Math.min(5.0, newScale));
                    
                    if (newScale !== this.scale) {
                        // **핵심 수정: 너비 맞춤 모드에서 일반 모드 전환 감지**
                        const isFromWidthFit = this.fitMode === 'width';
                        
                        console.log('=== 마우스 휠 축소/확대 ===');
                        console.log('현재 fitMode:', this.fitMode);
                        console.log('너비 맞춤에서 전환:', isFromWidthFit);
                        console.log('스케일 변경:', this.scale, '→', newScale);
                        
                        // 현재 컨테이너 중앙 좌표 계산
                        const container = this.pdfContainer;
                        const containerCenterX = container.clientWidth / 2;
                        const containerCenterY = container.clientHeight / 2;
                        
                        let currentCenterX, currentCenterY;
                        
                        if (isFromWidthFit) {
                            // **너비 맞춤에서 전환할 때는 화면 중앙 기준**
                            console.log('너비 맞춤에서 전환 - 화면 중앙 기준 적용');
                            currentCenterX = containerCenterX;
                            currentCenterY = containerCenterY;
                        } else {
                            // 일반적인 경우: 현재 스크롤 위치 기준
                            currentCenterX = container.scrollLeft + containerCenterX;
                            currentCenterY = container.scrollTop + containerCenterY;
                        }
                        
                        // 스케일 비율 계산
                        const scaleRatio = newScale / this.scale;
                        
                        // 내부 상태 업데이트
                        this.scale = newScale;
                        this.fitMode = 'none'; // 맞춤 모드 해제
                        this.updateFitToggle();
                        this.updateUI();
                        
                        // 이미지와 스크롤 영역 즉시 업데이트
                        this.updateImageSize();
                        this.updateScrollAreaForZoom();
                        
                        // **스크롤 위치 조정**
                        if (isFromWidthFit) {
                            // 너비 맞춤에서 전환 시 중앙 정렬 강제 적용
                            this.forceCenterAlignment();
                            
                            const pdfWidth = this.originalPageWidth * newScale;
                            const pdfHeight = this.originalPageHeight * newScale;
                            const containerWidth = container.clientWidth;
                            const containerHeight = container.clientHeight;
                            
                            if (pdfWidth <= containerWidth && pdfHeight <= containerHeight) {
                                // PDF가 컨테이너보다 작으면 스크롤 없음
                                container.scrollLeft = 0;
                                container.scrollTop = 0;
                                console.log('작은 PDF - 스크롤 없음');
                            } else if (pdfWidth <= containerWidth) {
                                // 가로는 중앙, 세로만 스크롤 가능
                                container.scrollLeft = 0;
                                container.scrollTop = 0;
                                console.log('가로 중앙, 세로 스크롤 가능');
                            } else {
                                // 가로/세로 모두 스크롤 가능 - 중앙에서 시작
                                const centerScrollLeft = Math.max(0, (pdfWidth - containerWidth) / 2);
                                const centerScrollTop = Math.max(0, (pdfHeight - containerHeight) / 2);
                                
                                container.scrollLeft = centerScrollLeft;
                                container.scrollTop = centerScrollTop;
                                console.log('마우스 휠 - 가로/세로 중앙 스크롤:', { centerScrollLeft, centerScrollTop });
                            }
                        } else {
                            // 일반적인 경우: 기존 중앙 기준 유지
                            const newCenterX = currentCenterX * scaleRatio;
                            const newCenterY = currentCenterY * scaleRatio;
                            
                            const newScrollLeft = newCenterX - containerCenterX;
                            const newScrollTop = newCenterY - containerCenterY;
                            
                            // 스크롤 위치 설정
                            container.scrollLeft = Math.max(0, Math.min(newScrollLeft, container.scrollWidth - container.clientWidth));
                            container.scrollTop = Math.max(0, Math.min(newScrollTop, container.scrollHeight - container.clientHeight));
                        }
                        
                        // 텍스트 레이어만 디바운스로 업데이트
                        this.scheduleTextLayerUpdate();
                        
                        // 줌 완료
                        this.isZooming = false;
                    }
                } else {
                    // 일반 스크롤 - 스크롤 끝에 도달했을 때만 페이지 전환
                    const container = this.pdfContainer;
                    const scrollTop = container.scrollTop;
                    const scrollHeight = container.scrollHeight;
                    const clientHeight = container.clientHeight;
                    
                    // 세로 스크롤 상태 확인
                    const canScrollVertically = scrollHeight > clientHeight;
                    const isAtTop = scrollTop <= 10;
                    const isAtBottom = scrollTop + clientHeight >= scrollHeight - 10;
                    
                    // 위로 스크롤하면서 맨 위에 있고 이전 페이지가 있는 경우
                    if (e.deltaY < 0 && isAtTop && this.currentPage > 1) {
                        e.preventDefault();
                        this.previousPage();
                    } 
                    // 아래로 스크롤하면서 맨 아래에 있고 다음 페이지가 있는 경우
                    else if (e.deltaY > 0 && isAtBottom && this.currentPage < this.totalPages) {
                        e.preventDefault();
                        this.nextPage();
                    }
                    // 그 외의 경우는 일반 스크롤 동작 허용
                }
            }

            async handleResize() {
                // 페이지 이동 중이면 리사이즈 처리 지연
                if (this.isPageTransitioning) {
                    setTimeout(() => this.handleResize(), 100);
                    return;
                }

                // 실제 디바이스 변경과 반응형 처리 분리
                const wasActualMobile = this.isMobile;
                const actualMobile = this.detectMobile();
                
                // 실제 디바이스 타입이 변경된 경우만 UI 재설정
                if (wasActualMobile !== actualMobile) {
                    this.isMobile = actualMobile;
                    this.setupMobileUI();
                    this.applyDeviceClass(); // 이 줄 추가
                    this.lastOpenedSidebarType = this.isMobile ? 'thumbnails' : 'folder';
                    this.folderBtn.title = this.isMobile ? '파일 선택' : '폴더 탐색기';
                }
                
                // 반응형 사이드바 처리 (창 크기 기반)
                this.handleResponsiveSidebar();

                // 툴바 요소 크기 재조정
                if (this.totalPages > 0) {
                    this.updatePageInputWidth();
                    this.updateZoomSelectWidth();
                }
                
                // 드롭다운이 열려있으면 위치 재계산
                if (this.isDropdownOpen) {
                    this.showDropdown();
                }
                
                if (this.fitMode !== 'none' && this.pdf) {
                    this.startZooming();
                    
                    const page = await this.pdf.getPage(this.currentPage);
                    let newScale;
                    
                    if (this.fitMode === 'width') {
                        newScale = await this.calculateFitToWidthScale(page);
                    } else if (this.fitMode === 'page') {
                        newScale = await this.calculateFitToPageScale(page);
                    } else {
                        return;
                    }
                    
                    this.scale = newScale;
                    this.updateFitToggle();
                    this.updateUI();
                    this.updateImageSize();
                    this.updateScrollAreaForZoom();
                    this.scheduleTextLayerUpdate();
                    this.isZooming = false;
                }
            }

            async handleKeyboard(e) {
                if (!this.pdf) return;

                // PDF 뷰어가 활성화된 상태에서만 키보드 단축키 동작
                if (this.pdfViewer.style.display === 'none') return;
                
                // 썸네일 창이 열려있을 때는 특정 키만 허용
                if (this.isThumbnailWindowOpen) {
                    switch(e.key) {
                        case 'Escape':
                            // ESC: 선택 해제 또는 창 닫기
                            if (this.isSelectionMode && this.selectedPages.size > 0) {
                                e.preventDefault();
                                this.clearSelection();
                            } else {
                                e.preventDefault();
                                this.closeThumbnailWindow();
                                setTimeout(() => {
                                    this.updateThumbnailButtonState();
                                }, 10);
                            }
                            break;
                        case 'q':
                        case 'Q':
                            // Ctrl+Q: 썸네일 창 닫기
                            if (e.ctrlKey) {
                                e.preventDefault();
                                this.closeThumbnailWindow();
                            }
                            break;
                        case 'c':
                        case 'C':
                            // Ctrl+C: 선택된 페이지들 복사 (추가)
                            if (e.ctrlKey && this.isSelectionMode && this.selectedPages.size > 0) {
                                e.preventDefault();
                                await this.copySelectedPages();
                            }
                            break;
                        case 'a':
                        case 'A':
                            // Ctrl+A: 전체 선택 (선택 모드일 때만)
                            if (e.ctrlKey && this.isSelectionMode) {
                                e.preventDefault();
                                this.selectAllThumbnails();
                            }
                            break;
                        // 다른 모든 키는 차단
                        default:
                            e.preventDefault();
                            return;
                    }
                    return; // 썸네일 창이 열려있을 때는 여기서 함수 종료
                }

                // 썸네일 창이 닫혀있을 때만 아래 기존 키보드 단축키들 실행
                switch(e.key) {
                    case 'Escape':
                        // ESC 키로 모달, 캡쳐 모드, 드롭다운 또는 사이드바 종료
                        if (this.helpModal.classList.contains('show')) {
                            e.preventDefault();
                            this.hideHelpModal();
                        } else if (this.propertiesModal.classList.contains('show')) {
                            e.preventDefault();
                            this.hideDocumentProperties();
                        } else if (this.isCaptureMode) {
                            e.preventDefault();
                            this.exitCaptureMode();
                            this.showToastMessage('✂️ 캡쳐 모드가 종료되었습니다');
                        } else if (this.isDropdownOpen) {
                            e.preventDefault();
                            this.hideDropdown();
                        } else if (this.isIconPanelOpen) {
                            // 사이드바가 열려있으면 전체 닫기
                            e.preventDefault();
                            this.toggleIconPanel();
                            this.showToastMessage('📄 사이드바가 닫혔습니다');
                        }
                        break;
                    case 'b':
                    case 'B':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            this.toggleIconPanel();
                            const message = this.isIconPanelOpen ? '📄 사이드바가 열렸습니다' : '📄 사이드바가 닫혔습니다';
                            this.showToastMessage(message);
                        }
                        break;
                    case 'q':
                    case 'Q':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            // 썸네일 창 열기
                            if (this.pdf && this.thumbnails.length > 0) {
                                this.openThumbnailWindow();
                            } else {
                                this.showToastMessage('📄 PDF를 먼저 로드해주세요');
                            }
                        }
                        break;
                    case 'x':
                    case 'X':
                        if (e.ctrlKey && e.shiftKey && !this.isCaptureMode) {
                            e.preventDefault();
                            this.toggleCaptureMode();
                            if (this.isCaptureMode) {
                                // 캡쳐 모드 활성화 메시지는 toggleCaptureMode에서 처리
                            } else {
                                this.showToastMessage('✂️ 캡쳐 모드가 종료되었습니다');
                            }
                        }
                        break;
                    case 'ArrowLeft':
                        // 왼쪽 화살표 - 이전 페이지 (스크롤 상태 무관)
                        if (!this.isCaptureMode) {
                            e.preventDefault();
                            await this.previousPage();
                        }
                        break;
                    case 'ArrowRight':
                        // 오른쪽 화살표 - 다음 페이지 (스크롤 상태 무관)
                        if (!this.isCaptureMode) {
                            e.preventDefault();
                            await this.nextPage();
                        }
                        break;
                    case 'ArrowUp':
                        // 위쪽 화살표 - 스크롤이 맨 위면 이전 페이지
                        if (!this.isCaptureMode && this.pdfContainer.scrollTop <= 10 && this.currentPage > 1) {
                            e.preventDefault();
                            await this.previousPage();
                        }
                        // 그 외에는 기본 스크롤 동작
                        break;
                    case 'ArrowDown':
                        // 아래쪽 화살표 - 스크롤이 맨 아래면 다음 페이지
                        if (!this.isCaptureMode) {
                            const container = this.pdfContainer;
                            if (container.scrollTop + container.clientHeight >= container.scrollHeight - 10 && this.currentPage < this.totalPages) {
                                e.preventDefault();
                                await this.nextPage();
                            }
                        }
                        // 그 외에는 기본 스크롤 동작
                        break;
                    case 'i':
                    case 'I':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            // 드롭다운 메뉴 토글
                            this.toggleDropdown();
                        }
                        break;
                    case 'c':
                    case 'C':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            await this.smartCopy();
                        }
                        break;
                    case 'a':
                    case 'A':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            // 페이지 입력 필드에 포커스가 있으면 해당 필드 내용만 전체 선택
                            if (document.activeElement === this.pageInput) {
                                // 기본 동작 허용 (페이지 입력 필드 전체 선택)
                                return;
                            } else {
                                // PDF 텍스트 전체 선택
                                e.preventDefault();
                                this.selectAllPDFText();
                            }
                        }
                        break;
                    case '=':
                    case '+':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            await this.zoomPage(1.25);
                        }
                        break;
                    case '-':
                        if (e.ctrlKey && !this.isCaptureMode) {
                            e.preventDefault();
                            await this.zoomPage(0.8);
                        }
                        break;
                }
            }

            // 사용 방법 모달 표시
            showHelpModal() {
                this.generateHelpContent();
                
                // 모달 표시 (애니메이션과 함께)
                this.helpModal.style.display = 'flex';
                setTimeout(() => {
                    this.helpModal.classList.add('show');
                }, 10);
            }

            // 사용 방법 모달 숨기기
            hideHelpModal() {
                this.helpModal.classList.remove('show');
                setTimeout(() => {
                    if (!this.helpModal.classList.contains('show')) {
                        this.helpModal.style.display = 'none';
                    }
                }, 300);
            }

            // 사용 방법 내용 생성
            generateHelpContent() {
                const isMobile = this.isMobile;
                
                this.helpContent.innerHTML = `
                    <div class="help-section">
                        <h3>🎮 키보드 단축키</h3>
                        <ul>
                            <li><strong>페이지 이동:</strong> <code>←</code> <code>→</code> 이전/다음 페이지, <code>↑</code> <code>↓</code> 스크롤 끝에서 페이지 이동</li>
                            <li><strong>확대/축소:</strong> <code>Ctrl + +</code> 확대, <code>Ctrl + -</code> 축소, <code>Ctrl + 휠</code> 마우스 중심 확대</li>
                            <li><strong>복사/선택:</strong> <code>Ctrl + C</code> 스마트 복사, <code>Ctrl + A</code> 전체 선택</li>
                            <li><strong>UI 제어:</strong> <code>Ctrl + B</code> 사이드바, <code>Ctrl + Q</code> 축소판 창, <code>Ctrl + I</code> 메뉴</li>
                            <li><strong>특수 기능:</strong> <code>Ctrl + Shift + X</code> 영역 캡쳐, <code>ESC</code> 모든 창/모드 종료</li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <h3>📁 파일 관리</h3>
                        <ul>
                            <li><strong>${isMobile ? '파일' : '폴더'} 선택:</strong> ${isMobile ? '파일 선택 버튼' : '폴더 선택 버튼'}으로 ${isMobile ? '개별 PDF 파일' : '전체 폴더 구조'} 로드</li>
                            <li><strong>드래그 앤 드롭:</strong> PDF 파일들을 직접 끌어다 놓기 (${isMobile ? '모바일에서는 단일 파일만' : '여러 파일 가능'})</li>
                            <li><strong>폴더 탐색기:</strong> <strong>📁</strong> 아이콘으로 선택된 폴더의 모든 PDF 파일 관리</li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <h3>🖼️ 보기 옵션</h3>
                        <ul>
                            <li><strong>축소판:</strong> <strong>🖼️</strong> 아이콘 또는 <code>Ctrl + Q</code>로 페이지 축소판 보기</li>
                            <li><strong>페이지 맞춤:</strong> <strong>↕️/↔️</strong> 버튼으로 페이지 맞춤과 너비 맞춤 전환</li>
                            <li><strong>확대/축소:</strong> <strong>+/-</strong> 버튼이나 배율 선택으로 조정</li>
                            <li><strong>테마:</strong> <strong>🌙/☀️/⚙️</strong> 버튼으로 다크/라이트/시스템 테마 순환</li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <h3>📋 복사 및 캡쳐</h3>
                        <ul>
                            <li><strong>스마트 복사:</strong> <strong>📋</strong> 버튼 - 텍스트 선택 시 텍스트, 미선택 시 이미지 복사</li>
                            <li><strong>자동 복사:</strong> 메뉴에서 활성화하면 페이지 이동 시 자동으로 클립보드 복사</li>
                            <li><strong>영역 캡쳐:</strong> <strong>✂️</strong> 버튼으로 원하는 영역을 드래그하여 선택 후 복사</li>
                            <li><strong>다중 선택:</strong> 축소판 창에서 여러 페이지를 선택하여 일괄 복사 가능</li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <h3>⚙️ 추가 기능</h3>
                        <ul>
                            <li><strong>문서 속성:</strong> 메뉴에서 PDF 파일의 상세 정보 확인</li>
                            <li><strong>토스트 메시지:</strong> 메뉴에서 알림 표시 여부 설정</li>
                            <li><strong>텍스트 선택:</strong> PDF 내 텍스트를 마우스로 드래그하여 선택 및 복사</li>
                            <li><strong>스와이프 이동:</strong> ${isMobile ? '좌우 스와이프로 페이지 이동' : '터치 기기에서 좌우 스와이프로 페이지 이동'}</li>
                        </ul>
                    </div>
                    
                    <div class="help-section">
                        <h3>💡 팁</h3>
                        <ul>
                            <li><strong>축소판 다중 선택:</strong> 축소판 창에서 <strong>☑️</strong> 버튼으로 선택 모드 활성화</li>
                            <li><strong>범위 선택:</strong> 선택 모드에서 <code>Shift + 클릭</code>으로 범위 선택</li>
                            <li><strong>모바일 최적화:</strong> ${isMobile ? '터치 친화적 인터페이스로 최적화됨' : '모바일에서도 동일한 기능 제공'}</li>
                            <li><strong>성능 최적화:</strong> 고품질 렌더링과 빠른 반응속도의 균형</li>
                        </ul>
                    </div>
                `;
            }

            // scrollToTop 함수 다음에 추가
            scrollToTopOptimized() {
                const container = this.pdfContainer;
                
                // 강제 리플로우로 최신 레이아웃 정보 확보
                container.offsetHeight;
                
                // 기본 모드에서는 wrapper의 padding을 고려한 스크롤 위치 계산
                let targetScrollTop = 0;
                
                if (this.fitMode === 'none' && this.scale > 1.0) {
                    // 확대된 기본 모드에서는 margin을 고려
                    const pdfHeight = this.originalPageHeight * this.scale;
                    const containerHeight = container.clientHeight;
                    
                    if (pdfHeight > containerHeight) {
                        // wrapper의 paddingTop이나 margin을 고려
                        const wrapperStyle = getComputedStyle(this.pdfWrapper);
                        const paddingTop = parseFloat(wrapperStyle.paddingTop) || 0;
                        
                        // padding이 있다면 그 위치까지 스크롤
                        targetScrollTop = Math.max(0, paddingTop);
                    }
                } else if (this.fitMode === 'width') {
                    // 너비 맞춤 모드에서는 항상 0
                    targetScrollTop = 0;
                } else {
                    // 페이지 맞춤 모드에서는 스크롤 없음
                    targetScrollTop = 0;
                }
                
                container.scrollTop = targetScrollTop;
                container.scrollLeft = Math.max(0, container.scrollLeft); // 가로 스크롤 유지하되 음수 방지
            }

            scrollToBottomOptimized() {
                const container = this.pdfContainer;
                
                // 강제 리플로우
                container.offsetHeight;
                
                // 최대 스크롤 위치로 이동
                const maxScrollTop = Math.max(0, container.scrollHeight - container.clientHeight);
                container.scrollTop = maxScrollTop;
            }

            validateScrollArea() {
                const container = this.pdfContainer;
                
                // 스크롤 영역이 올바른지 검증하고 필요시 조정
                const maxScrollTop = Math.max(0, container.scrollHeight - container.clientHeight);
                const maxScrollLeft = Math.max(0, container.scrollWidth - container.clientWidth);
                
                // 현재 스크롤 위치가 범위를 벗어나면 조정
                if (container.scrollTop > maxScrollTop) {
                    container.scrollTop = maxScrollTop;
                }
                if (container.scrollLeft > maxScrollLeft) {
                    container.scrollLeft = maxScrollLeft;
                }
                
                // 음수 값 방지
                if (container.scrollTop < 0) {
                    container.scrollTop = 0;
                }
                if (container.scrollLeft < 0) {
                    container.scrollLeft = 0;
                }
            }
        }

        // 앱 초기화
        document.addEventListener('DOMContentLoaded', () => {
            // 페이지 로드 시 즉시 시스템 테마 적용
            applyInitialSystemTheme();
            
            // PDF 뷰어 초기화하고 전역 참조 저장
            window.pdfViewerInstance = new PDFClipboard();
        });

        // 초기 시스템 테마 적용 (페이지 로드 시)
        function applyInitialSystemTheme() {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                // 시스템이 다크모드면 기본 상태 유지 (다크모드)
                document.body.classList.remove('light-theme');
            } else {
                // 시스템이 라이트모드면 라이트 테마 적용
                document.body.classList.add('light-theme');
            }
            
            // 시스템 테마 변경 감지
            if (window.matchMedia) {
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                mediaQuery.addEventListener('change', (e) => {
                    // PDF 뷰어가 로드되지 않은 상태에서도 테마 변경 적용
                    if (e.matches) {
                        document.body.classList.remove('light-theme');
                    } else {
                        document.body.classList.add('light-theme');
                    }
                    
                    // 동적 색상 업데이트를 위해 setupMobileUI 호출 (전역적으로 접근 가능하도록)
                    const pdfViewer = window.pdfViewerInstance;
                    if (pdfViewer && pdfViewer.setupMobileUI) {
                        pdfViewer.setupMobileUI();
                    }
                });
            }
        }
    </script>
</body>
</html>
